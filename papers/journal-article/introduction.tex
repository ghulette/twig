%!TEX root = twig.tex

\chapter{Introduction}
\label{ch:intro}

Programmers design, write, and understand programs with a
high-level structure in mind. In most cases, however, that
structure is not captured in the artifacts resulting from the
coding process. This occurs because programming languages are not
very good at expressing the high-level and/or domain-specific
logic of a program. There are simply too many details to capture
in the lower-level logic of any non-trivial program, and these
details obscure and possibly even subvert the higher-level logic.
This is especially true in the very common case where a program
undergoes multiple modifications, rewrites, extensions, and
refactoring over the course of its lifetime -- even if the
high-level logic were captured, perhaps in natural language
comments or design documents, its relationship to the actual code
weakens over time.

The kind of high-level structure we are concerned with typically
arises from the programmer's domain-specific thought process and
reasoning. Often, the logic may be quite simple, at least
conceptually -- sequences of operations, conditional branches,
cycles, and the like, although the exact semantics of these
structures within the logic of a particular domain may differ and
be more complex when compared against the versions found within a
mainstream programming language.

\section{Benefits of capturing high-level structure}

If we could somehow capture this high-level logic, what might we
do with it? First, since it expresses domain-specific structure,
it could be used for \emph{domain-specific optimization}. For
example, in a GPU code, if the high-level logic captures memory
copying operations, we could recognize a redundant copy and
eliminate it. This optimization might be quite difficult to do if
the algorithm were written in a language that does not capture
high-level structure. In C, for example, GPU memory copies are
performed via API calls that appear as regular functions and are
therefore outside the scope of the compiler to analyze.

Second, in some cases we can design reusable software tools, such
as code generators or runtime engines, that enable programmers or
domain experts to work with the high-level structure and leave the
low-level details to an automated tool. \emph{Workflow systems}
are an interesting and successful example of this kind of tool.

Third, if the high-level logic is somehow associated with the
final code, it may serve as a high-quality and high-fidelity form
of \emph{documentation}, enabling a programmer to grasp the
high-level interpretation of a program more easily.

\section{Existing approaches}

Programmers are, of course, aware that this kind of high-level
information is both important and difficult to capture, and so
there have been several attempts to improve the situation.

The most common method for capturing high-level information is
informal documentation based on natural language descriptions of
the program components and their intended functionality. In this
case, the information may be embedded in code comments, perhaps
using a structured comment tool such as Doxygen or JavaDoc. Or, it
may be captured in an entirely separate document. Either way, the
informal nature of this sort of documentation does not capture
much (if any) logical structure, and does not lend itself to the
kind of reasoning we are interested in. Furthermore, the loose
connection between documentation and the code it describes
infamously leads to out-of-date, misleading, or completely
inaccurate descriptions. This phenomenon is often referred to as
``version skew,'' as the version of software referred to in the
documentation gradually deviates from the most current version. In
many cases, for a programmer attempting to understand code, this
scenario is worse than having no documentation at all.

Formal models, like those used by model checking tools such as
SPIN~\cite{spin}, do capture the kind of high-level program
structure we are interested in. Indeed, a model is essentially a
high-level abstraction of a program's behavior. However, these
kinds of models are not tied to the code and they cannot be used
to alter or optimize it directly. Also, as with informal
documentation, there is significant potential for version skew if
the program evolves and the model is not updated.

Workflow systems allow for the expression of high-level structure
in a domain-agnostic fashion, but are typically informal and
involve complex external requirements. A workflow-based program's
behavior is essentially defined by the workflow runtime used to
execute it, and this can make such programs brittle and hard to
maintain as the software evolves. Workflow programming systems
also tend to focus on coordination of relatively large components,
such as whole applications, which often have little in common in
terms of their design. Since the components tend to be so
heterogeneous, it is uncommon for these systems to provide ways to
reason about the semantics of the workflow as a whole.

We discuss these approaches further in
Chapter~\ref{ch:background}.

\section{Twig}

Ideally, we would like a programming paradigm that allows for
high-level, domain-specific logic to be encoded alongside the
low-level implementation details in a way that binds the two
together. The high-level structure would organize the low-level
details, and be available for automated analysis, reasoning, and
formal verification. The low-level logic, meanwhile, would be
available for modification and tuning by the programmer. Ideally,
this hypothetical system would also allow programmers to
incorporate their own domain- or application-specific rules,
allowing them to reason about and exploit the exposed high-level
structure. Such a system would lead to software that is easier to
develop and maintain, since it would be easier for both humans and
machines to reason about than today's typical programming
languages allow. It would also be much easier for humans to
interpret and understand programs written in this way, since the
high-level structure would be provided explicitly, and would never
become out-of-date. Through these benefits, we argue that this
type of system would represent an important advancement in the way
that programs are written.

Twig is a language for writing \emph{typemaps} -- small,
declarative programs used to translate data from one
representation to another. Twig represents a step in the direction
for programming we envision above, by uniting two levels of
semantic information in one program. In Twig, programmers are able
to express programs in terms of a combined high- and low-level
logic, with the final program being synthesized automatically.
Twig's high-level logic is based on a simple, formal calculus that
is amenable to either human or machine reasoning, and can be
adapted with extra rules for reasoning in domain-specific
contexts. The low-level domain code is expressible, in theory, in
any mainstream programming language. Our implementation allows for
C and Python, and can be extended to support other languages.

Twig is, in many ways, quite similar to typemap-based tools like
SWIG, but it equips SWIG's typemap language design with extra
structure and expressiveness. The result is a language that is
flexible while remaining broadly applicable to practical problems.
We exploit its structure by introducing the idea of
\emph{reductions}, which allow for user-defined, domain-specific
typemap optimizations and transformations.

Twig addresses the issues identified above:

\begin{enumerate}

\item\textbf{The high-level, domain-specific structure of a
program is lost in the process of writing low-level code.} Twig's
language, while restricted to relatively small programs called
\emph{typemaps}, is a move in the direction of providing
high-level structure over low-level program code. The high-level
aspect of a Twig program is based on just a few combinators,
described in Chapter~\ref{ch:semantics}. Twig's relatively simple
primitives and combinators restrict the program's semantics, but
allow for easier reasoning, analysis, and transformation. In
particular, Twig's high-level combinators are adaptable enough to
express domain-specific constructions and transformations; we
demonstrate this with examples in Chapter~\ref{ch:eval}.

% TODO: This seems like it is risky. Do you speak about the danger
% of putting arbitrary code in there?

\item\textbf{Programs written at a very high level lose the
flexibility that low-level coding affords.} Twig aims to provide a
bridge between high-level abstraction and low-level code. Twig
allows for low-level code, written in languages such as C or
Python, to be embedded in primitives. The programmer is then able
to work with the primitives at a high-level, using Twig's
combinators. The output of a Twig program is the low-level code,
combined and synthesized according to the high-level rules. Thus,
the low-level representation is available for flexibility, but is
still subject to the structure imposed at the high level.

Domain-specific languages are generally a purely high-level
approach, and are typically tied to a particular domain. Twig, by
comparison, can be customized and applied to many different
domains. We review some approaches to domain-specific programming
in Chapter~\ref{ch:background}, and show how Twig can be applied
in two application domains, GPU programming and multi-language
programming, in Chapter~\ref{ch:eval}.

Twig's set of high-level combinators can be used to build program
structures similar to those commonly found in workflow systems.
Unlike workflow systems, Twig generates code instead of managing
its execution at runtime. This approach has the advantage of
decoupling the workflow implementation from the abstraction
presented to the programmer. We review some existing workflow
systems in Chapter~\ref{ch:background}.

% TODO: Sort of. Seems that embedding code as mentioned on the
% previous page violates this. May want to make it clear how this
% is ok.

\item\textbf{Existing approaches to capturing the high-level
structures of low-level code are fragile, because the two
representations evolve independently and can become inconsistent.}
Twig's language associates low-level code, written in languages
like C or Python, with primitive structures in its high-level
logic. These primitives are combined via a set of simple
combinators. In addition, unlike formal modeling tools, in Twig
neither the low nor high levels of the program can be changed
without impacting the overall program's behavior, and thus the
high-level and low-level semantics are tightly coupled. We
describe the lower-level semantics for code block synthesis in
Chapter~\ref{ch:code-gen}, and our implementation in
Section~\ref{sec:impl:code-gen}. These primitives can be combined
using Twig's high-level semantics, described in
Chapter~\ref{ch:semantics}.

\item\textbf{Programs that lack explicit high-level structure can
be difficult to optimize in domain-specific ways.} Twig programs
can be \emph{reduced}, via both built-in and user-defined rules
for reorganizing and combining expressions. Twig's simple
high-level logic makes such rules easy to describe and express. By
providing the proper domain-specific rules, domain-specific
optimizations may be designed, even by end-users. The process of
reduction is described in Section~\ref{ch:reductions}, and we give
the details of our implementation in
Section~\ref{sec:impl:reductions}.
Sections~\ref{sec:eval:multi-lang} and \ref{sec:eval:gpu}
demonstrate practical examples.

\item\textbf{Programs that lack explicit high-level structure
force programmers to work at an inappropriate level of
abstraction.} Twig allows programmers to abstract their own
low-level code, and then work with it in a domain abstraction. It
also exposes the high-level structure for analysis. We exploit
this capability with reductions, presented in
Section~\ref{ch:reductions}.

\end{enumerate}

% TODO: May want to lift this earlier, so that the previous
% section connects to the novel contributions you make.

\section{Contributions}

To summarize, with Twig we have made the following novel
contributions:

\begin{enumerate}

\item Designed a simple model for low-level code synthesis;

\item Extended the semantics of System S to incorporate this
model;

\item Shown how term rewriting tools can be used to reduce
typemaps written in our language;

\item Implemented a prototype of this language;

\item Demonstrated the utility of typemap reductions in a domain
where they had not previously been applied: that of GPU
programming.

\end{enumerate}
