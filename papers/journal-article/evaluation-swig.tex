%!TEX root = twig.tex

\section{Twig Compared}
\label{sec:eval:swig}

We now walk through the construction of a simple typemap in Twig.
In this example, our goal is to convert a set of C structures
representing polar coordinates to a suitable representation in
Python. The C structure comes in both a \texttt{float} and
\texttt{double} variety. The Python code expects a Cartesian
coordinate system, not polar, so we must perform this conversion
as well. The C structures we will convert are defined in a header
file, like so:

\begin{verbatim}
struct PolarD {
  double r;
  double theta;
};
struct PolarF {
  float r;
  float theta;
};
\end{verbatim}

The first step is to unpack each polar structure into a Twig
tuple. We define two rules to do exactly this:

\begin{verbatim}
unpackd = [polard -> (double,double)] <<<
  $out1 = $in.r;
  $out2 = $in.theta;
>>>

unpackf = [polarf -> (float,float)] <<<
  $out1 = $in.r;
  $out2 = $in.theta;
>>>
\end{verbatim}

Next, we define a rule for casting \texttt{float}s to
\texttt{double}s, and use the congruence operator to lift it to a
conversion on tuples. This cast is sequenced after
\texttt{unpackf} so that that rule will produce \texttt{double}s
instead of \texttt{float}s. We combine that conversion with
\texttt{unpackd} using the choice operator, and name the new rule
\texttt{unpack}. This new rule will accept either a
\texttt{polarf} or a \texttt{polard}, and produce a 2-tuple of
\texttt{double}s.

\begin{verbatim}
f2d = [float -> double] <<<
  $out = (double)$in;
>>>

unpack = (unpackf;{f2d,f2d}) | unpackd
\end{verbatim}

Next, we define the conversion from polar to Cartesian
coordinates.

\begin{verbatim}
polarToX = [(double,double) -> double] <<<
  $out = $in1 * cos($in2);  
>>>

polarToY = [(double,double) -> double] <<<
  $out = $in1 * sin($in2);
>>>
\end{verbatim}

These two rules take a pair of \texttt{double}s, which represent a
polar radius and angle, and convert the pair to the $x$
(respectively, $y$) component of the equivalent Cartesian
representation. But, we need both the $x$ and $y$ components, and
we only have one polar pair. We use the \emph{fanout} operator to
duplicate the pair, and then sequence it with a congruence of the
$x$ and $y$ rules, like so:

\begin{verbatim}
polarToCart = #fan(2);{polarToX,polarToY}
\end{verbatim}

The rule \texttt{polarToCart} will convert a polar coordinate pair
of \texttt{doubles} to a Cartesian pair of \texttt{double}s.

Next, we define rules to convert from C types to Python. We use
Python's C interface API~\cite{python-c-api}, which allows us to
work with Python values in C.

\begin{verbatim}
d2pyf = [double -> pyfloat] <<<
  $out = PyFloat_FromDouble($in);
>>>

mkpytuple = [(pyfloat,pyfloat) -> 
             pytuple(pyfloat,pyfloat)] 
<<<
  $out = PyTuple_Pack(2,$in1,$in2);
>>>

pack = {d2pyf,d2pyf};mkpytuple
\end{verbatim}

The first rule, \texttt{d2py} converts a C \texttt{double} to
Python's floating-point type, which we call
\texttt{pyfloat}.~\footnote{In the API, a \texttt{pyfloat} is
actually mapped to a more general \texttt{PyObject *}; one
interesting benefit of Twig is that it can potentially track more
detailed type information than would be available from API
itself.} The next rule, \texttt{mkpytuple} will combine a pair of
\texttt{pyfloats} into a single Python tuple object (\emph{not} a
Twig tuple). The \texttt{pack} rule combines these in the usual
way to convert a pair of C \texttt{doubles} to a Python tuple.

Finally, by placing these parts in sequence, we achieve our goal:
a single rule which will convert either a \texttt{PolarD} or
\texttt{PolarF} \texttt{struct} in C into a Cartesian coordinate
in Python. We call the final rule \texttt{convert}.

\begin{verbatim}
convert = unpack;polarToCart;pack
\end{verbatim}

We can invoke Twig with this typemap as its program. To generate
the C code to perform the transformation, we apply
\texttt{convert} to one of the terms \texttt{polarf} or
\texttt{polard}. If we choose \texttt{polarf}, Twig will generate
the code to convert a \texttt{PolarF} \texttt{struct}, like so:

\begin{verbatim}
PyObject *convert(struct PolarF gen1) {
  float gen2,gen3;
  double gen4,gen5,gen6,gen7;
  PyObject *gen8,*gen9,*gen10;
  gen2 = gen1.r;
  gen3 = gen1.theta;
  gen4 = (double)gen2;
  gen5 = (double)gen3;
  gen6 = gen4 * cos(gen5);  
  gen7 = gen4 * sin(gen5);
  gen8 = PyFloat_FromDouble(gen6);
  gen9 = PyFloat_FromDouble(gen7);
  gen10 = PyTuple_Pack(2,gen8,gen9);
  return gen10;
}
\end{verbatim}

\subsection{Versus SWIG}

It is interesting to contrast Twig's implementation of the typemap
example above with the equivalent typemaps in SWIG. In that
system, programmers are required to construct two separate
typemaps by hand, like so:

\begin{verbatim}
%typemap(out) struct PolarD %{
  double r = $1.r;
  double theta = $1.theta;
  double x = r * cos(theta);
  double y = r * sin(theta);
  PyObject *px = PyFloat_FromDouble(x);
  PyObject *py = PyFloat_FromDouble(y);
  $result = PyTuple_Pack(2,px,py);
%}

%typemap(out) struct PolarF %{
  float fr = $1.r;
  float ftheta = $1.theta;
  double r = (double)fr;
  double theta = (double)ftheta;
  double x = r * cos(theta);
  double y = r * sin(theta);
  PyObject *px = PyFloat_FromDouble(x);
  PyObject *py = PyFloat_FromDouble(y);
  $result = PyTuple_Pack(2,px,py);
  }
%}
\end{verbatim}

Even in this simple example, there is a considerable amount of
duplicated code across the two typemaps. This duplication is
unnecessary in Twig since simple typemaps, such as those to
convert polar to Cartesian coordinates or convert C
\texttt{double}s to Python, can be recombined and reused. In
addition, the choice operator helps to reduce the overall number
of typemaps needed, since one typemap can be used to generate
different code depending on the input.

Twig has a few other advantages over SWIG. First, Twig allows sets
of types to be mapped together using tuples. This is a common
problem -- consider function argument lists, or a pointer paired
with a length to form an array.

Second, Twig has greater flexibility with respect to target
languages. In particular, Twig can be extended to generate target
languages other than C. Our implementation, for example, is able
to generate Python as well as C. SWIG is currently able to
generate only C.

\subsection{Versus Fig}

Twig shares much of its core semantics with Fig, but Twig aims to
serve a more general role as a typemapping language for a variety
of applications. In particular, Fig is intimately tied to its
target language, Moby. Twig, by contrast, can support a large
range of mainstream languages. Our own implementation supports C
and Python, and Twig's abstract formal semantics for code
generation are designed to allow other languages to be
incorporated easily.

In addition, unlike Fig, Twig's primitive rules may be
polymorphic, allowing variables in place of types. For example,
certain primitive rules in Twig such as

\begin{verbatim}
deref = [ptr(X) -> X] <<<
  $out = *$in;
>>>
\end{verbatim}

would be difficult to express with as much generality in Fig.
Instead, a different primitive rule would be required for each
specific type.
