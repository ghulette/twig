%!TEX root = twig.tex

\section{Typemap Tools}
\label{sec:background:typemap}

In multi-language programming, there is always the question of how to relate the data types in one language to the types in another. For low-level, primitive types such as integers and floating point numbers, the mapping is usually obvious because both languages are likely to have to types that correspond very closely, if not exactly. The question becomes more complicated, however, for higher-level data types. For example, consider the following C \texttt{struct} and function declaration:

\begin{verbatim}
struct Point {
  double x, y;
};

double norm(struct Point *p);
\end{verbatim}

How would an IDL or FFI expose \texttt{norm} to, say, Java? One possibility would map the \texttt{Point} structure to the \texttt{java.awt.Point} class, and construct a \texttt{norm} method in Java like so:

\begin{verbatim}
double norm(java.awt.Point p);
\end{verbatim}

There are other options, as well. For example, \texttt{Point} could be mapped to \texttt{java.awt.geom.Point2D.Double}, or even to a new point class, defined by recursively mapping individual elements of the structure to corresponding new instance variables. A \emph{type map} is some data structure or algorithm that allows these cases to be disambiguated. Type mapping is a common feature across many kinds of multi-language interoperability systems, because it is difficult in general to match types across languages. These systems may be quite simple and/or inflexible. In particular, many systems require that user-defined types by translated to some simpler type with a known cross-language mapping, in order to be passed across language boundaries. The examples we cover here are more involved. In particular, high-level type mapping systems allow arbitrary user-defined types to be mapped to across language boundaries in ways that are, to some extend, customizable by the programmer.

%%
%% EXAMPLES
%%

\subsection{Examples}

In this section we will examine some examples of systems that have popular or interesting approaches to high-level type mapping.

\subsubsection{SWIG}

SWIG~\cite{beazley96swig} is a ``wrapper generator'', intended to generate tedious glue code needed for higher-level languages to interact with lower-level ones. It has a particular focus on connecting so-called ``scripting'' languages, such as Python, Ruby, and Perl, to pre-existing libraries written in C. SWIG can be configured to generate any kind of glue code, so the exact output will depend on the FFI system used. To call a C function from these languages, glue code must be generated that converts the function arguments from the scripting language representation to some representation in C, invokes the C function, checks for possible error codes, converts the return value to a high-level representation, and finally transfers control back to the high-level language.

To direct the code generation, the SWIG tool takes an interface file as input. The interface consists of ANSI C function prototypes and variable declarations. SWIG handles simple primitive type conversions automatically. By default, SWIG does not perform sophisticated type mapping. Instead, it simply converts pointer types in C to an ``opaque pointer'' type in the high-level language. Opaque pointers are represented as the pointer's contents (i.e., an address in memory) encoded as hexadecimal strings. Null pointers are converted to the string value ``NULL''. This scheme treats pointers as opaque handles, which may only be used by passing them to (appropriately typed) wrapped C functions.

If a more involved mapping of pointer types is desired, SWIG has a notion of type mapping functions~\cite{swigtypemaps}. A type mapping function is a block of glue code that implements a conversion from a low-level C data type to some high-level type in the scripting language, or vice-versa. In general, to convert from C to a high-level language and back requires a pair of symmetric type maps. The code in a typemap can be arbitrarily complex. For example, it could pick apart a C structure, field by field, instantiate a new object in Python, set some fields in the Python object instance, and then return the object.

To insert the code block that implements a type conversion, SWIG must be able to recognize the data types to which it applies. SWIG uses a regular expression pattern, paired with each type map definition, to match types lexically. SWIG extends the pattern matching to account for things like aliased types. Once a type is matched, the type mapping code will be inserted into the generated glue code at the appropriate point to convert the data type.

Parameterizing SWIG with a set of typemaps defines a type mapping \emph{policy}. By changing the typemaps, the policy will be changed. SWIG is distributed with a set of default type maps, but users are free to define their own and augment or replace the defaults.

We compare a typemap written in SWIG to an equivalent one written
in our own language, Twig, in Section~\ref{sec:eval:swig}.


\subsubsection{FIG}

FIG is a tool used to wrap existing C libraries for
Moby~\cite{reppy06ffi}. Since Moby already uses BOL as a
language-neutral IR (see Section~e.g.,), the mechanism for
interoperability with C is already in place. Fig's job is to fix a
policy that maps types in C to types in Moby, and is able to
generate the BOL code that implements the conversion.

The input to FIG is a C header file along with a script that is
used to guide the translation of types. Internally, FIG represents
the contents of the header file (i.e., function type declarations)
as a set of typed terms, and transforms the terms from C to Moby
through the application of \emph{term rewriting} rules~(see
Appendix~\ref{sec:background:trs}). Typemaps in FIG are built from
rewriting rules whose input terms are BOL types, and whose output
is either another BOL type or $\bot$, which indicates failure. The
use of BOL's language-neutral type representations allows type
terms to be uniformly represented in BOL, while still translating
between Moby and C.

A typemap in FIG is a 4-tuple, consisting of a high-level type
$T_m$, a low-level type $T_c$, a marshalling function that
converts a value of type $T_m$ to a value of type $T_c$, and an
unmarshalling function that converts values from $T_c$ back to
$T_m$. The marshalling and unmarshalling functions are defined in
BOL. When FIG needs to generate conversion code for a type, it
simply checks to see if a registered typemap takes that type as
input, and then inserts the marshalling or unmarshalling code to
perform the conversion.

FIG also defines a combinator language that allows simple typemaps
to be composed into more complex conversions. The composition
rules are based on term rewriting \emph{strategies}, and System S
in particular (see Section~\ref{sec:background:trs}). Strategies
allow flexible composition of typemaps, including simple
constructions like sequencing (i.e., the output of one typemap is
sent to the input of another), or more complex rules like mapping
a typemap across the elements of tupled types. Typemap combinators
are a useful and powerful feature that distinguishes FIG from
other approaches to typemapping. We adopt FIG's combinators in
Twig's language, as described in Chapter~\ref{ch:semantics}.

FIG also has a pattern matching feature, not unlike that of SWIG,
that can select terms based on identifiers or other lexical
constructs. This can be used, for example, to disambiguate cases
when two typemaps may apply to the same type, or to apply certain
typemaps only when particular naming conventions are being used in
the header file.

Twig was partially inspired by FIG. We designed Twig to be similar
to FIG in terms of its language, but with the ability to generate
code for target languages other than Moby.

% TODO: Elaborate on how FIG is the basis for our own work.


\subsubsection{PolySPIN}

PolySPIN is a multi-language interoperability system designed for object-oriented languages~\cite{barrett96polyspin}. It seeks to make interoperability for any number of OOP languages totally \emph{seamless}, i.e., such that a programmer need never be aware that they are working with objects written in a different language. PolySPIN rejects the IDL approach, since it requires programmers to define an interface in terms of the IDL. Even if the interface is automatically generated, it does supports only a limited type system, and so using the interface is unnatural when high-level types, including objects, are involved.

PolySPIN's approach to interoperability is based on automatically generated mappings between high-level types, using a process called ``type matching''. Matching objects are pairs of inter-language object types that have equivalent, or roughly equivalent, interfaces. PolySPIN implements this check using \emph{signature matching}~\cite{zaremski93matching}. Strict signature matching works by equating a set of primitive types across languages (e.g., a Java \texttt{int} is defined to match a C++ \texttt{int}), and then recursively equating constructed types, including method signatures and objects. Matching can also be relaxed in various ways; for example, an object may match another object if they match strictly except that the first object contains additional methods that are not in the second object. Matching criteria in PolySPIN can be defined by programmers, and may include lexical criteria such as a type's identifier.

To make use of matching, PolySPIN introduces a system that binds a unique name to each object in a multi-language application. The methods of each object are modified so that they consult this binding whenever they are invoked. If the underlying object is instantiated locally in the calling language, the method is invoked normally. But it is also possible that the object is acting a facade to a matched object in another language. In this case, when a method is invoked, PolySPIN redirects the method call back to the underlying object in the original language. Facade objects may be obtained by passing regular objects across language boundaries, for example in a method's arguments. In any case, when an object is passed to a different language, a matching type is found, and is used as a facade to the original object.

It is worth noting one drawback of PolySPINs approach -- because PolySPIN must modify the methods of each class, the full program source code must be available. So, existing libraries for which only the compiled code is available cannot be used with PolySPIN.

\subsection{Discussion}

The systems in this section illustrate the use of type maps in multi-language programming. Type maps are best viewed as a feature of these systems, rather than a general approach to interoperability. The goal of high-level type maps, generally, is to make programming in multi-language applications more natural by allowing programmers to use familiar high-level types instead of a restricted, predefined set interoperable types. As with all marshalling code, high-level type maps may be at odds with efficiency, since they potentially introduce extraneous transformations.
