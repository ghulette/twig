%!TEX root = twig-gpu.tex

\section{Introduction}

Writing code for accelerators such as GPUs can be tedious and error prone. One
problem is that the dominant methods for programming in these environments,
such as CUDA or OpenGL, provide only a low-level interface to the hardware.
For many programmers, in particular domain programmers such as simulation
scientists, a higher-level interface may be desired. The trade-off, however,
may be a pronounced decrease in performance. Since performance is generally
the salient reason to use an accelerator in the first place, this situation
represents a major impediment to the widespread adoption of accelerator
hardware environments by non-specialist programmers.

One of the major potential impediments to performance on accelerators, of
particular hazard to high-level programming models, is redundant memory
movement. Accelerators typically possess their own special-purpose memory,
separate from the main system memory. Programmers must explicitly copy data
from the system to the accelerator before it can be processed there. Once the
data is processed, it must be copied back into the system memory. Copying
memory to and from the device is typically quite slow, presenting one of the
major bottlenecks for accelerator performance. Programmers must be careful,
therefore, to copy data only as needed, and to do as much processing as
possible on the device before copying the data back to the system.

Another problem with high-level accelerator programming environments is that
of integration with existing and supporting code. Scientists at Sandia, for
example, typically write code in popular general-purpose languages such as
C/C++, Fortran, or Python. They also make frequent use of the vast catalog of
libraries in these same languages. Domain-specific accelerator languages which
cannot integrate, or integrate only with difficulty, with existing codes in
these languages are of limited use in these scenarios.

In this paper we present a high level code generation language called
\emph{Twig} and show how it can be used to overcome the obstacles to
high-level accelerator programming described above. In particular, Twig allows
for simple, high-level accelerator programming, and at the same time supports
automated reasoning about composite programs that can, in many cases, avoid
redundant memory copying and thereby retain high performance. Finally, Twig's
role in the programming toolchain is to generate code in a mainstream language
like C. The generated code is then incorporated into a surrounding program,
which is built as usual. This minimizes the complexity that Twig adds to the
build process, and allows Twig code to interact easily with existing code and
libraries.

Twig achieves these goals through a formal basis in term rewriting, along with
a scheme which uses data types to direct the generation of code in the target
language. In particular, we augment existing data types in the target language
with a notion of \emph{location}, e.g., an array of floats located on a GPU,
or an integer located in main memory. We describe the details of this approach
in the following section.

% Why C? Because it is lingua franca, and it is the language of accelerator %
% APIs.
