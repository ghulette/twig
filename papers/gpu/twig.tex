%!TEX root = twig-gpu.tex

\section{Twig}

% Overview of how Twig works, basic semantics, code generation, simple
% example. Focus on importance of generating C - integration with existing
% methods, type-directed generation.

Twig is based on a core semantics called System S~\cite{Visser:1998p333}.
System S was originally designed for specifying term rewriting systems
(described briefly in \ref{section:term-rewriting}). In Twig, we use the
operators of System S to combine primitive \emph{rules} into more complex
transformations on types. These transformations are then applied to a given
type, which performs the transformation and generates code as a side effect.
In this way, domain specific code can be generated depending on the input
types. In this section we describe the basics of Twig's language.

\subsection{Values}

Values in Twig can be any valid \emph{term}. Terms are tree structured data
with labeled internal nodes. Examples of terms include simple values like
\texttt{int} and \texttt{float}, as well as compound types like
\texttt{ptr(int)}, which represents a pointer to an integer.

Note that terms in Twig are intended to correspond to types in the target
language. The programmer can control the mapping via a configuration file.
Furthermore, the mapping need not be injective, i.e. you can have multiple
values in Twig map to the same type in C. For example, you might have distinct
Twig values \texttt{string} and \texttt{ptr(char)}, but both represent a
\texttt{char *} in C. 

In Twig, terms may also represent tuples. For example, \texttt{(string,int)}
represents the product of two types in C, a \texttt{string} and an
\texttt{int}.

\subsection{Rules}

The basic building blocks of a Twig program are called \emph{rules}. A rule
describes a basic transformation between terms. For example, in C it is easy
to convert an integer to a float. In Twig, this rule is written

\begin{verbatim}
[int -> float]
\end{verbatim}

The term to the left of the arrow is the input, and the term to the right is
the output. In this example, the rule says that if the input value is
\texttt{int} then it will be rewritten to the value \texttt{float}. If the
input is not \texttt{int} then it will be rewritten to the special value
$\bot$, which can be read as ``failure.''

Rules can also have \emph{variables} in place of terms or sub-terms. For
example the rule

\begin{verbatim}
[ptr(X) -> X]
\end{verbatim}

rewrites any pointer type to its referent.

\subsection{Combinators}

Rules can be combined into more complex expressions using a fixed set of
operators. The most important is the \emph{sequence} binary operator, which
chains the application of two rules together, feeding the output of the first
into the input of the second, and failing if either rule fails. With this
operator, simple rules can be composed into multi-step transformations.

Another important binary operator is \emph{left-biased choice}. This operator
will try the first rule expression, and if it succeeds then its output is the
result. If it fails (i.e. results in $\bot$), then the second rule is tried.
This operator allows different paths to be taken, and different code to be
generated, depending on the input type being passed.

In the semantics for Twig's operators, given below, let $t$ ranges over terms,
and $s_i$ ranges over rule expressions (i.e. a primitive rule, or another rule
expression built with operators).

Sequence:

\[
\infer{t \arr{s_1;s_2} t''}{t \arr{s_1} t' \quad t' \arr{s_2} t''}
\qquad 
\infer{t \arr{s_1;s_2} \bot}{t \arr{s_1} \bot}
\qquad
\infer{t \arr{s_1;s_2} \bot}{t \arr{s_1} t' \quad t' \arr{s_2} \bot}
\]

Left-biased choice:

\[
\infer{t \arr{s_1|s_2} t'}{t \arr{s_1} t'}
\qquad 
\infer{t \arr{s_1|s_2} t'}{t \arr{s_1} \bot \quad t \arr{s_2} t'}
\qquad
\infer{t \arr{s_1|s_2} \bot}{t \arr{s_1} \bot \quad t \arr{s_2} \bot}
\]

Constants:

\[
\infer{t \arr{\mathtt{id}} t}{}
\qquad
\infer{t \arr{\mathtt{fail}} \bot}{}
\]

Discard result:

\[
\infer{t \arr{?s} t}{t \arr{s} t'}
\qquad 
\infer{t \arr{?s} \bot}{t \arr{s} \bot}
\qquad
\infer{t \arr{\lnot s} \bot}{t \arr{s} t'}
\qquad 
\infer{t \arr{\lnot s} t}{t \arr{s} \bot}
\]

Fix-point:

\[
\infer{t \arr{\mu x(s)} t'}{t \arr{s[x := \mu x(s)]} t'}
\qquad 
\infer{t \arr{\mu x(s)} \bot}{t \arr{s[x := \mu x(s)]} \bot}
\]

All the following tuple combinators share these failure semantics:

\[
\infer{f(\ldots) \arr{s} \bot}
{f \neq \mathtt{tuple}}
\qquad
\infer{\mathtt{tuple}(t_1,\ldots,t_n) \arr{s(i)} \bot}{i > n}
\]

Projection:

\[
\infer{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i} t_i}{}
\]

Path:

\[
\infer{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} 
\mathtt{tuple}(\ldots,t_i',\ldots)}
{t_i \arr{s} t_i'}
\]

\[
\infer{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} \bot}
{t_i \arr{s} \bot}
\]

Congruence:

\[
\infer{
\mathtt{tuple}(t_1,\ldots,t_n)
\arr{(s_1,\ldots,s_n)}
\mathtt{tuple}(t_1',\ldots,t_n') }
{t_1 \arr{s_1} t_1' \quad \ldots \quad t_n \arr{s_n} t_n'}
\]

\[
\infer{
\mathtt{tuple}(\ldots,t_i,\ldots)
\arr{(\ldots,s_i,\ldots)}
\bot}
{t_i \arr{s_i} \bot}
\]

Branch:

\[
\infer{
  t \arr{\mathtt{\#branch}(s_1,\ldots,s_n)}
  \mathtt{tuple}(t_1',\ldots,t_n')
}{t \arr{s_1} t_1' \quad \ldots \quad t \arr{s_n} t_n'}
\]

\[
\infer
{t \arr{\mathtt{\#branch}(\ldots,s_i,\dots)} \bot}
{t \arr{s_i} \bot}
\]

Map:

\[
\infer{
  \mathtt{tuple}(t_1,\ldots,t_n)
  \arr{\mathtt{\#map}(s)}
  \mathtt{tuple}(t_1',\ldots,t_n')
}{t_1 \arr{s} t_1' \quad \ldots \quad t_n \arr{s} t_n'}
\]

\[
\infer
{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\mathtt{\#map}(s)} \bot}
{t_i \arr{s} \bot}
\]

\subsection{Code generation}

Our implementation of Twig generates C code, but in principle almost any
language could be generated instead.

\subsection{Reductions}

Reductions are a way to transform Twig expressions. Reductions may exploit
some application or domain knowledge about the nature of the rules, and as
such are usually developed alongside a set of rules.

% Explain reductions and how they can be used in domain- or
% application-specific ways.

\subsection{Term rewriting}
\label{section:term-rewriting}

% Brief overview of term rewriting and how it is used in reductions.

\subsection{Implementation}

% Talk briefly about how Twig is implemented, and how to use it to generate
% code.
