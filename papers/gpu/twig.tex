%!TEX root = twig-gpu.tex

\section{Twig}

% Overview of how Twig works, basic semantics, code generation, simple
% example. Focus on importance of generating C - integration with existing
% methods, type-directed generation.

Twig is based on a core semantics called System S~\cite{Visser:1998p333}.
System S was originally designed for specifying term rewriting
systems~\cite{baader98rewriting}. In Twig, we use the operators of System S to
combine primitive \emph{rules} into more complex transformations on types.
These transformations are then applied to a given type, which performs the
transformation. We extend the semantics of System S in order to have the
evaluation of the transformation generate code as a side effect. In this way,
domain specific code can be generated depending on the input types. In this
section we describe the basics of Twig's language.

\input{codegen}

\subsection{Values}

Values in Twig can be any valid \emph{term}. Terms are tree structured data
with labeled internal nodes. Examples of terms include simple values like
\texttt{int} and \texttt{float}, as well as compound types like
\texttt{ptr(int)}, which represents a pointer to an integer.

Note that terms in Twig are intended to represent types in the target
language. The programmer can control the mapping via a configuration file.
Furthermore, the mapping need not be injective, i.e. you can have multiple
values in Twig map to the same type in C. For example, you might use distinct
Twig values \texttt{string} and \texttt{ptr(char)}, but have both represent a
\texttt{char *} in C.

In Twig, terms may also represent tuples. Tuples are represented with either a
special constructor \texttt{tuple}, or equivalently (and preferably) with no
constructor at all. For example, \texttt{(string,int)} (or, equivalently
\texttt{tuple(string,int)}) represents a pair of two types in C, a
\texttt{string} and an \texttt{int}. The \texttt{tuple} constructor syntax is
convenient mainly for our presentation of formal semantics for tuple
operators, given below.

\subsection{Rules}

The basic building blocks of a Twig program are called \emph{rules}. A rule
describes a basic transformation between terms. For example, in C it is easy
to convert an integer to a float. In Twig, this rule is written

\begin{verbatim}
[int -> float]
\end{verbatim}

The term to the left of the arrow is the input, and the term to the right is
the output. In this example, the rule says that if the input value is
\texttt{int} then it will be rewritten to the value \texttt{float}. If the
input is not \texttt{int} then it will be rewritten to the special value
$\bot$, which can be read as ``failure.''

Rules can also have \emph{variables} in place of terms or sub-terms. For
example the rule

\begin{verbatim}
[ptr(X) -> X]
\end{verbatim}

rewrites any pointer type to its referent. The variable \texttt{X} is bound to
the corresponding value of the matched input on the right, and that value is
then substituted for the variable where it appears on the left. Variables
match whole sub-terms only; e.g., rules such as \texttt{[X(int) -> X]} are
invalid.

Finally, primitive rules may generate code as a side effect of successful
application. To include code with a rule, you put it immediately after the
rule definition and surround it with braces, like so:

\begin{verbatim}
[int -> float] {
  $out = (float)$in;
}
\end{verbatim}

As part of the code generation, Twig will assign \texttt{\$in} and
\texttt{\$out} elements generated C variable names, and ensure that they are
declared with the appropriate type. If there are multiple inputs or outputs,
then the relevant placeholders are enumerated; e.g., \texttt{\$in1},
\texttt{\$in2}, and so on.

It is important to understand that Twig does not check the code in any way,
and the generation procedure is strictly syntactic. This scheme is similar to
that used by SWIG~\cite{swig}.

\subsection{Combinators}

Rules can be combined into more complex expressions using Twig's operators. In
the formal semantics, let $t$ range over terms, $m$ range over code
expressions and $s_i$ range over rule expressions (i.e. a primitive rule, or
another rule expression built with operators).

A primitive rule $s$ transforms $t$ to $t'$ with generated code $m$:

\[
t \arr{s} (t',m)
\]

if the application of rule $s$ to value $t$ succeeds. If no code is given for
the rule, then $m$ is the ``no-op'' element, $e$. If the application of $s$ to
$t$ fails, e.g., if $t$ does not match the pattern in $s$, then we say

\[
t \arr{s} \bot
\]

Note that no code is generated in this case.

The most important of Twig's combinators is the \emph{sequence} operator,
which chains the application of two rules together, providing the output of
the first to the input of the second, and failing if either rule fails (see
Figure~\ref{semantics:sequence}). With this operator, simple rules can be
composed into multi-step transformations.

\begin{figure}[ht]
\label{semantics:sequence}
\[
\infer{t \arr{s_1;s_2} (t'',m_1+m_2)}{t \arr{s_1} (t',m_1) \quad t' \arr{s_2} (t'',m_2)}
\qquad 
\infer{t \arr{s_1;s_2} \bot}{t \arr{s_1} \bot}
\qquad
\infer{t \arr{s_1;s_2} \bot}{t \arr{s_1} (t',m) \quad t' \arr{s_2} \bot}
\]
\caption{Semantics for sequence operator}
\end{figure}

Another important binary operator is \emph{left-biased choice}. This operator
will try the first rule expression, and if it succeeds then its output is the
result (see Figure~\ref{semantics:choice}). If it fails (i.e. results in
$\bot$), then the second rule is tried. This operator allows different paths
to be taken, and different code to be generated, depending on the input type
being passed.

\begin{figure}[ht]
\label{semantics:choice}
\[
\infer{t \arr{s_1|s_2} (t',m)}{t \arr{s_1} (t',m)}
\qquad 
\infer{t \arr{s_1|s_2} (t',m)}{t \arr{s_1} \bot \quad t \arr{s_2} (t',m)}
\qquad
\infer{t \arr{s_1|s_2} \bot}{t \arr{s_1} \bot \quad t \arr{s_2} \bot}
\]
\caption{Semantics for left-biased choice}
\end{figure}

Figure~\ref{semantics:basic} gives the formal semantics for Twig's other
operators. These include constant operators, operators which discard their
results, and a fix point operator for recursion.

\begin{figure}[ht]
\label{semantics:basic}
\[
\infer{t \arr{\mathtt{id}} (t,I)}{}
\qquad
\infer{t \arr{\mathtt{fail}} \bot}{}
\]

\[
\infer{t \arr{?s} (t,I)}{t \arr{s} (t',m)}
\qquad 
\infer{t \arr{?s} \bot}{t \arr{s} \bot}
\qquad
\infer{t \arr{\lnot s} \bot}{t \arr{s} (t',m)}
\qquad 
\infer{t \arr{\lnot s} (t,I)}{t \arr{s} \bot}
\]

% Include fix-point operator?
% \[
% \infer{t \arr{\mu x(s)} t'}{t \arr{s[x := \mu x(s)]} t'}
% \qquad 
% \infer{t \arr{\mu x(s)} \bot}{t \arr{s[x := \mu x(s)]} \bot}
% \]
\caption{Semantics for basic operators}
\end{figure}

Twig also provides some special operators for tuples. The semantics in
Figure~\ref{semantics:all-tuples} apply to all the tuple operators, and state
simply that tuple operators will fail if the input term is not a tuple, or if
the rule references a tuple element out of bounds.


\begin{figure}[ht]
\label{semantics:all-tuples}
\[
\infer{f(\ldots) \arr{s} \bot}
{f \neq \mathtt{tuple}}
\qquad
\infer{\mathtt{tuple}(t_1,\ldots,t_n) \arr{s(i)} \bot}{i > n}
\]
\caption{Common semantics for tuple operators}
\end{figure}


One important tuple operator is \emph{congruence}, which applies a tuple of
rules to a tuple of values, and returns a tuple of results or failure if any
one rule application fails. The semantics are given in
Figure~\ref{semantics:congruence}.


\begin{figure}[ht]
\label{semantics:congruence}
\[
\infer{
\mathtt{tuple}(t_1,\ldots,t_n)
\arr{(s_1,\ldots,s_n)}
(\mathtt{tuple}(t_1',\ldots,t_n'),m_1 \times \ldots \times m_n) }
{t_1 \arr{s_1} (t_1',m_1) \quad \ldots \quad t_n \arr{s_n} (t_n',m_n)}
\]
\[
\infer{
\mathtt{tuple}(\ldots,t_i,\ldots)
\arr{(\ldots,s_i,\ldots)}
\bot}
{t_i \arr{s_i} \bot}
\]
\caption{Semantics for congruence operator}
\end{figure}


The \emph{branch} operator on tuples applies a tuple of rules to a single
term, and produces a tuple of results with one element per rule. The branch
operator has several semantic variants; we present one in
Figure~\ref{semantics:branch} wherein the branch operation fails if any single
rule fails. We elide the other semantics, as well as the \emph{map} operator,
which are similar in principle.

\begin{figure}[ht]
\label{semantics:branch}
\[
\infer{
  t \arr{\mathtt{\#branch}(s_1,\ldots,s_n)}
  (\mathtt{tuple}(t_1',\ldots,t_n'),I_n + (m_1 \times \ldots \times m_n))
}{t \arr{s_1} (t_1',m_1) \quad \ldots \quad t \arr{s_n} (t_n',m_n)}
\]
\[
\infer
{t \arr{\mathtt{\#branch}(\ldots,s_i,\dots)} \bot}
{t \arr{s_i} \bot}
\]
\caption{Semantics for branch operator}
\end{figure}


Finally, we have the \emph{projection} and \emph{path} operators, which
extract a single element from a tuple, and apply a rule to a single element,
respectively. The semantics are given in Figure~\ref{semantics:projection} and
Figure~\ref{semantics:path}.


\begin{figure}[ht]
\label{semantics:projection}
\[
\infer{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i} 
(t_i,\Pi_{\{i\}})}{}
\]
\caption{Semantics for projection operator}
\end{figure}


\begin{figure}[ht]
\label{semantics:path}
\[
\infer{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)}
(\mathtt{tuple}(\ldots,t_i',\ldots),
I_1 \times \ldots \times m \times \ldots \times I_1)}
{t_i \arr{s} (t_i',m)}
\]
\[
\infer{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} \bot}
{t_i \arr{s} \bot}
\]
\caption{Semantics for path operator}
\end{figure}

% Include map operator?
% \[
% \infer{
%   \mathtt{tuple}(t_1,\ldots,t_n)
%   \arr{\mathtt{\#map}(s)}
%   \mathtt{tuple}(t_1',\ldots,t_n')
% }{t_1 \arr{s} t_1' \quad \ldots \quad t_n \arr{s} t_n'}
% \]
% \[
% \infer
% {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\mathtt{\#map}(s)} \bot}
% {t_i \arr{s} \bot}
% \]

\subsection{Expression names}
\label{section:names}

For convenience, Twig allows rules and rule expressions to be assigned names,
like so:

\begin{verbatim}
intToFloat = [int -> float] {
  $out = (float)$in;
}
\end{verbatim}

This assigns a primitive rule to the name \texttt{intToFloat}. Names must
begin with lower-case letters, and can only be used once. Now that name can be
used in place of the rule itself in expressions, like this:

\begin{verbatim}
pairOfIntsToFloats = (intToFloat,intToFloat)
\end{verbatim}

A Twig program is a list of such name/expression assignments. There is a
special expression name, \texttt{main}, which designates the top-level
expression for the program.

\subsection{Integration with C}
\label{twig:concrete-code-gen}

Twig is capable of generating any procedural language, but in practice
implementations must take the target language into account. Our current
implementation of Twig is targeted to generate C code. For convenience, our
implementation will handle tasks such as declaring variables, generating
unique names, and ensuring that for sequencing blocks the outputs are assigned
to the inputs in the appropriate way. 

Optionally, generated code may be wrapped in a C function body, with
parameters corresponding to the inputs, and return value corresponding to the
output. In this case, Twig insists that the code block have a non-tuple output
type, since C functions cannot return multiple values.

\subsection{Reductions}

Reductions are a mechanism provided within Twig as a way to automatically
simplify expressions. Reductions usually exploit some application or domain
knowledge about the nature of the primitive rules, and as such are usually
developed alongside a set of rules.

As an example, consider the following two rules.

\begin{verbatim}
intToFloat = [int -> float] {
  $out = (float)$in;
}

floatToInt = [float -> int] {
  $out = (int)$in;
}
\end{verbatim}

and the expression

\begin{verbatim}
intToFloat;floatToInt
\end{verbatim}

This conversion is redundant and, if we encounter it, we might as well
eliminate it. This can be accomplished with the following reduction:

\begin{verbatim}
reduce intToFloat;floatToInt => id
\end{verbatim}

This statement introduces a new reduction rule which instructs Twig to replace
any subexpression \texttt{intToFloat;floatToInt} with the identity rule,
\texttt{id}. Recall that \texttt{id} is the identity rule; it simply passes
the value through unchanged.

Twig also comes with some default reductions. These special reductions use
knowledge of Twig's combinators to perform further reductions. One example is
identity elimination, which will replace subexpressions of the form
\texttt{id;X} with \texttt{X}, where \texttt{X} is a variable representing any
subexpression.

Reductions must be developed carefully to avoid infinite loops. This is
surprisingly easy to do accidentally, even with simple rules. For example,
Twig will not terminate if it is given these two reductions

\begin{verbatim}
reduce foo;bar => baz
reduce baz => foo;bar
\end{verbatim}

and one of them applies within the program. It will continually rewrite
\texttt{foo;bar} to \texttt{baz}, and then back again, ad infinitum.

Twig's reductions are based on the formal theory of term
rewriting~\cite{baader98rewriting}. In this case Twig's expressions, not its
values, are the terms being rewritten.

% Talk about finding a normal form for Twig expressions? Probably beyond the
% scope of this paper.

% \subsection{Term rewriting}
% \label{section:term-rewriting}

% Brief overview of term rewriting and how it is used in reductions.

\subsection{Implementation}

Our implementation of Twig is written in Haskell. Twig expects as input a
\texttt{.twig} file containing a list of named rule expressions along with a
\texttt{main} rule expression, as described in Section~\ref{section:names}. It
also expects an initial value (i.e. a term, representing a C type), which will
be used as the input to the main rule expression.

Twig must also be configured with a mapping from terms to C types. Currently,
this mapping is provided with a simple key/value text file, but we are working
on a more flexible alternative.

If the input value can be successfully rewritten using the main rule
expression provided, then Twig will output the rewritten term along with the
generated block of C code. If desired, this code block may be redirected to a
separate file and included in a C program using the \texttt{\#include}
directive.

We are currently examining ways in which this process might be more easily
incorporated into a typical C programmer's workflow.
