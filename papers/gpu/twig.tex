%!TEX root = twig-gpu.tex

\section{Twig}

% Overview of how Twig works, basic semantics, code generation, simple
% example. Focus on importance of generating C - integration with existing
% methods, type-directed generation.

Twig is based on a core semantics called System S~\cite{Visser:1998p333}.
System S was originally designed for specifying term rewriting systems
(described briefly in \ref{section:term-rewriting}). In Twig, we use the
operators of System S to combine primitive \emph{rules} into more complex
transformations on types. These transformations are then applied to a given
type, which performs the transformation. We extend the semantics of System S
in order to have the evaluation of the transformation generate code as a side
effect. In this way, domain specific code can be generated depending on the
input types. In this section we describe the basics of Twig's language.

\subsection{Code generation}

Twig provides a basic but effective set of operations to perform code
generation. Our model is abstract, although we also discuss our concrete
implementation below. For our purposes, ``code'' is an abstract data type,
with two attributes: a list of inputs and a list of outputs. Each input and
output is described by a pair of a unique name, and also a term (described
below). There are two operations that are defined on code.

First

\subsection{Values}

Values in Twig can be any valid \emph{term}. Terms are tree structured data
with labeled internal nodes. Examples of terms include simple values like
\texttt{int} and \texttt{float}, as well as compound types like
\texttt{ptr(int)}, which represents a pointer to an integer.

Note that terms in Twig are intended to represent types in the target
language. The programmer can control the mapping via a configuration file.
Furthermore, the mapping need not be injective, i.e. you can have multiple
values in Twig map to the same type in C. For example, you might use distinct
Twig values \texttt{string} and \texttt{ptr(char)}, but have both represent a
\texttt{char *} in C.

In Twig, terms may also represent tuples. Tuples are represented with either a
special constructor \texttt{tuple}, or equivalently (and preferably) with no
constructor at all. For example, \texttt{(string,int)} (or, equivalently
\texttt{tuple(string,int)}) represents a pair of two types in C, a
\texttt{string} and an \texttt{int}. The \texttt{tuple} constructor syntax is
convenient mainly for our presentation of formal semantics for tuple
operators, given below.

\subsection{Rules}

The basic building blocks of a Twig program are called \emph{rules}. A rule
describes a basic transformation between terms. For example, in C it is easy
to convert an integer to a float. In Twig, this rule is written

\begin{verbatim}
[int -> float]
\end{verbatim}

The term to the left of the arrow is the input, and the term to the right is
the output. In this example, the rule says that if the input value is
\texttt{int} then it will be rewritten to the value \texttt{float}. If the
input is not \texttt{int} then it will be rewritten to the special value
$\bot$, which can be read as ``failure.''

Rules can also have \emph{variables} in place of terms or sub-terms. For
example the rule

\begin{verbatim}
[ptr(X) -> X]
\end{verbatim}

rewrites any pointer type to its referent.

\subsection{Combinators}

Rules can be combined into more complex expressions using a set of provided
operators. In the formal semantics, let $t$ range over terms, and $s_i$ range
over rule expressions (i.e. a primitive rule, or another rule expression built
with operators). Recall that $\bot$ denotes failure of rule application.

The most important operator is \emph{sequence}, which chains the application
of two rules together, feeding the output of the first into the input of the
second, and failing if either rule fails (see
Figure~\ref{semantics:sequence}). With this operator, simple rules can be
composed into multi-step transformations.

\begin{figure}[ht]
\label{semantics:sequence}
\[
\infer{t \arr{s_1;s_2} t''}{t \arr{s_1} t' \quad t' \arr{s_2} t''}
\qquad 
\infer{t \arr{s_1;s_2} \bot}{t \arr{s_1} \bot}
\qquad
\infer{t \arr{s_1;s_2} \bot}{t \arr{s_1} t' \quad t' \arr{s_2} \bot}
\]
\caption{Semantics for sequence operator}
\end{figure}

Another important binary operator is \emph{left-biased choice}. This operator
will try the first rule expression, and if it succeeds then its output is the
result (see Figure~\ref{semantics:choice}). If it fails (i.e. results in
$\bot$), then the second rule is tried. This operator allows different paths
to be taken, and different code to be generated, depending on the input type
being passed.

\begin{figure}[ht]
\label{semantics:choice}
\[
\infer{t \arr{s_1|s_2} t'}{t \arr{s_1} t'}
\qquad 
\infer{t \arr{s_1|s_2} t'}{t \arr{s_1} \bot \quad t \arr{s_2} t'}
\qquad
\infer{t \arr{s_1|s_2} \bot}{t \arr{s_1} \bot \quad t \arr{s_2} \bot}
\]
\caption{Semantics for left-biased choice}
\end{figure}

Figure~\ref{semantics:basic} gives the formal semantics for Twig's other
operators. These include constant operators, operators which discard their
results, and a fix point operator for recursion.

\begin{figure}[ht]
\label{semantics:basic}
\[
\infer{t \arr{\mathtt{id}} t}{}
\qquad
\infer{t \arr{\mathtt{fail}} \bot}{}
\]

\[
\infer{t \arr{?s} t}{t \arr{s} t'}
\qquad 
\infer{t \arr{?s} \bot}{t \arr{s} \bot}
\qquad
\infer{t \arr{\lnot s} \bot}{t \arr{s} t'}
\qquad 
\infer{t \arr{\lnot s} t}{t \arr{s} \bot}
\]

\[
\infer{t \arr{\mu x(s)} t'}{t \arr{s[x := \mu x(s)]} t'}
\qquad 
\infer{t \arr{\mu x(s)} \bot}{t \arr{s[x := \mu x(s)]} \bot}
\]
\caption{Semantics for basic operators}
\end{figure}

Twig also provides some special operators for tuples. The semantics in
Figure~\ref{semantics:all-tuples} apply to all the tuple operators, and state
simply that tuple operators will fail if the input term is not a tuple, or if
the rule references a tuple element out of bounds.

\begin{figure}[ht]
\label{semantics:all-tuples}
\[
\infer{f(\ldots) \arr{s} \bot}
{f \neq \mathtt{tuple}}
\qquad
\infer{\mathtt{tuple}(t_1,\ldots,t_n) \arr{s(i)} \bot}{i > n}
\]
\caption{Common semantics for tuple operators}
\end{figure}

One important tuple operator is \emph{congruence}, which applies a tuple of
rules to a tuple of values, and returns a tuple of results or failure if any
one rule application fails. The semantics are given in
Figure~\ref{semantics:congruence}.

\begin{figure}[ht]
\label{semantics:congruence}
\[
\infer{
\mathtt{tuple}(t_1,\ldots,t_n)
\arr{(s_1,\ldots,s_n)}
\mathtt{tuple}(t_1',\ldots,t_n') }
{t_1 \arr{s_1} t_1' \quad \ldots \quad t_n \arr{s_n} t_n'}
\]

\[
\infer{
\mathtt{tuple}(\ldots,t_i,\ldots)
\arr{(\ldots,s_i,\ldots)}
\bot}
{t_i \arr{s_i} \bot}
\]
\caption{Semantics for congruence operator}
\end{figure}

Projection:

\[
\infer{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i} t_i}{}
\]


Path:

\[
\infer{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} 
\mathtt{tuple}(\ldots,t_i',\ldots)}
{t_i \arr{s} t_i'}
\]

\[
\infer{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} \bot}
{t_i \arr{s} \bot}
\]

Branch:

\[
\infer{
  t \arr{\mathtt{\#branch}(s_1,\ldots,s_n)}
  \mathtt{tuple}(t_1',\ldots,t_n')
}{t \arr{s_1} t_1' \quad \ldots \quad t \arr{s_n} t_n'}
\]

\[
\infer
{t \arr{\mathtt{\#branch}(\ldots,s_i,\dots)} \bot}
{t \arr{s_i} \bot}
\]

Map:

\[
\infer{
  \mathtt{tuple}(t_1,\ldots,t_n)
  \arr{\mathtt{\#map}(s)}
  \mathtt{tuple}(t_1',\ldots,t_n')
}{t_1 \arr{s} t_1' \quad \ldots \quad t_n \arr{s} t_n'}
\]

\[
\infer
{\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\mathtt{\#map}(s)} \bot}
{t_i \arr{s} \bot}
\]

\subsection{Code generation}

Our implementation of Twig generates C code, but in principle almost any
language could be generated instead.

\subsection{Reductions}

Reductions are a way to transform Twig expressions. Reductions may exploit
some application or domain knowledge about the nature of the rules, and as
such are usually developed alongside a set of rules.

% Explain reductions and how they can be used in domain- or
% application-specific ways.

\subsection{Term rewriting}
\label{section:term-rewriting}

% Brief overview of term rewriting and how it is used in reductions.

\subsection{Implementation}

% Talk briefly about how Twig is implemented, and how to use it to generate
% code.
