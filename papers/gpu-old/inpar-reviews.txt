Dear Geoffrey Hulette -

We are sorry to inform you that your paper

169 - A Type-based Approach to Separating Protocol from Application Logic: A Case Study in Hybrid Computer Programming

has not been accepted to InPar 2012. The reviews are included below\; for a small number of papers, you might see another review included in another week or so in the review system.

At our in-person PC meeting, we worked hard to develop a good summary of the discussion beyond simply the reviews. This summary appears prior to the reviews below. (If the summary is not present at this time, please check back in the review system in a few days.) We hope it will be good feedback to you as you continue your research.

Sincerely,
Lorena Barba and John Owens, InPar 2012
inpar12-papers@googlegroups.com

-------------------- COMMENTS FROM THE COMMITTEE --------------------

Summary of the reviews:

It is an interesting idea to use type to help heterogeneous computing. The work appears to be in its preliminary stage. The use of simple examples is insufficient to convincingly show the practical value of the technique. Some related work is missing. The presentation can be improved.

------------------------ Submission 169, Review 5 ------------------------

Title: A Type-based Approach to Separating Protocol from Application Logic: A Case Study in Hybrid Computer Programming

Reviewer:           primary
Overall rating:     8  (scale is 3..15; 15 is best)

Overall Rating

  2  (Probably reject: I would argue for rejecting this paper.)

Novelty

  3  (Moderately novel)

Importance

  3  (Moderately important)

Expertise

  3  (Knowledgeable)

The Review

  The paper presents a programming system named Twig for simplifying
  programming on a heterogeneous machine. The major feature of Twig is
  to separate the specification of data movement (or called protocol
  logic) from the specification of computation. The mechanism to do so
  is augmented types having location of data encoded and some rewriting
  rules.

  At a high level, the paper tackles an important problem, removing
  barriers for heterogeneous programming, and the main idea is
  interesting. However, this work seems to be in a preliminary stage
  still.  The examples in the paper are all very simple, and the paper
  contains no systematic evaluation of the technique on real
  applications, in either performance or programmability. it is hard to
  see how broadly applicable and practically useful Twig is.

  Some relevant works are missing in the discussion, for example, the
  Offload work by Peter Cooper et al. has also used data types for
  indicating data locations.

  The presentation can be further enhanced. At some places, the
  presentation is wordy.

------------------------ Submission 169, Review 1 ------------------------

Title: A Type-based Approach to Separating Protocol from Application Logic: A Case Study in Hybrid Computer Programming

Reviewer:           external
Overall rating:     8  (scale is 3..15; 15 is best)

Overall Rating

  2  (Probably reject: I would argue for rejecting this paper.)

Novelty

  3  (Moderately novel)

Importance

  3  (Moderately important)

Expertise

  2  (Passing Knowledge)

The Review

  Programming for hybrid computers is difficult because the programmer have
  to explicitly handle the communication between different processors. As a
  result, the communication protocol and the application-level computation
  are intermingled. This paper tries to address this problem by proposing a
  higher-level script language, Twig, which allows programmers to specify
  the necessary data movement between different processors and how the
  movement should be done. The script in Twig could be translated into C
  code automatically, which will be combined with the part that handles
  application-level computation.

  The idea seems reasonable. However, given the current presentation, I
  cannot see how the problem is addressed. It seems to me that Twig is just
  a language for describing the data movement (i.e. the protocol logic).
  But how to first separate the protocol logic from application logic? Is
  it always doable? Is Twig helpful for this separation? Given a Twig
  script and the resulting C code implementing the protocol logic, how to
  combine it with the code implementing the application logic? Is the
  combination also specified in Twig or in other tools? Maybe a case study
  would be helpful.

  The language features of Twig are quite simple. The basic idea is to add
  location information to the target-level types, and then describe in Twig
  the type conversion (including the change of the location of the data
  type). All the examples shown in the paper are very simple. It is unclear
  if the Twig language is expressive enough for real applications.

  Calling this "type-based approach" is a bit misleading. Neither Twig nor
  the target language (C in this case) are type-safe languages.

------------------------ Submission 169, Review 2 ------------------------

Title: A Type-based Approach to Separating Protocol from Application Logic: A Case Study in Hybrid Computer Programming

Reviewer:           external
Overall rating:     5  (scale is 3..15; 15 is best)

Overall Rating

  1  (Definite reject: I would argue strongly for rejecting this paper.)

Novelty

  2  (Somewhat novel)

Importance

  2  (Somewhat important)

Expertise

  4  (Expert)

The Review

  The paper presents a technique that aims to help developers of GPU
  kernels by automatically generating the boilerplate code that is used to
  copy data to and from a GPU in languages like CUDA and OpenCL.  The basic
  idea is that the programmer can specify various commands, e.g.
  “copyToGPU”, as rules in a high-level language called Twig.  The user
  equips these rules with signatures that use intuitive data types (such as
  “array(float)” and “gpu(array(float))”), and in addition
  specifies some low-level code detailing the sequence of system calls that
  should implement the rule.  Finally, the user can specify some rewrite
  rules to do things like rewrite “copyFromGPU;copyToGPU” to “id”,
  thus eliminating a redundant copy.  This has the potential to aid in
  automatic optimizations such as kernel fusion.

  The paper contains some interesting ideas, and certainly high-level
  approaches to making GPU programming easier are in dire need.  However,
  the current state of this work appears to be very preliminary, and not
  substantiated by any kind of experimental evaluation.  The paper is easy
  to follow, but in places is quite waffly and repetitive, spelling out
  rather trivial details.  I believe the exposition could have been
  significantly compressed, to make way for some more compelling worked
  examples and a tighter, slightly more formal description of the Twig
  syntax and semantics.

  The paper is also quite thin on relevant related work.  The authors’
  work focuses on language support to relieve the burden of data movement.
  Some recent approaches to this problem in a multicore (though not GPU)
  setting include:

  Sequoia:
  Kayvon Fatahalian et al.: Sequoia: programming the memory hierarchy.
  Supercomputing, 2006
  Timothy Knight et al.: Compilation for explicitly managed memory
  hierarchies. PPoPP, 2007

  Offload:
  Pete Cooper et al.: Offload - Automating Code Migration to Heterogeneous
  Multicore System.  HiPEAC, 2010

  The Offload paper includes the notion of data types to specify the
  location of data.  The second Sequoia paper details some optimizations
  for minimising data movement that share common ground with this
  submission.  The authors should cite and briefly discuss these papers.

  There has been some interesting recent work on automatic code generation
  for GPUs using the polyhedral model which would also be worth briefly
  commenting on.  One such paper is:

  Muthu Baskaran et al.: A compiler framework for optimization of affine
  loop nests for GPGPUs.  ICS 2008.

  In summary, I think this is an interesting approach which I hope the
  authors will pursue further, but I do not think it is ready for
  publication at InPar.

  Detailed comments:

  Page 2, column 2: you mention “Reppy’s” FIG work, then later you
  talk about “Reppy and Song”.  If you are going to refer to them by
  name, I think you should talk about “Reppy and Song’s” FIG work.

  “one of the compilation techniques that was called out” – not clear
  what you mean by “called out” here.  Are you saying that the
  telescoping approach invoked various compilation techniques?

  Page 3, column 1: when you say “CUDA programmers are free to execute a
  kernel on the GPU before they have copied any data there”, perhaps
  spell out a little more clearly that this would be madness – the point
  you are making is that this erroneous (and probably accidental) behaviour
  is not presented by the CUDA setup.

  You say that “as we will see in Section 5”, Twig programs are
  significantly constrained with respect to control flow.  Am I right that
  it is not possible to write looping code in Twig?  I think this could be
  quite a big restriction.  One of the places where Twig might be very
  useful would be where two kernels are called in succession in the body of
  a loop.  In this case, your optimization for eliminating a redundant copy
  from GPU to CPU and back would be effective on every single loop
  iteration.  It would be a shame if your method could not be applied in
  this case.

  Section 3.1 of the paper, and the associated Figure 1, are very trivial.
  I think you could say what is said in this section much less verbosely
  – as you say, it is a very basic idea.  Figure 1 could take up
  significantly less space, and even so, you could make the text in the
  diagrams larger – right now it is painfully small!  You could use the
  space you would save to provide a more compelling worked example than
  your very simple example of Section 7.

  Top of page 4: “our current work is focused on leveraging this
  capability to its fullest” – you say this, but you have not presented
  any sort of experimental evaluation in the paper, so I don’t think you
  can really claim to be focused on full leverage of this simple idea!

  In Figure 4, it is not clear what the meaning of AxB is.  It looks like
  you have just sequentially composed the code from each block.  So what is
  parallel?  I must have missed something here, but I think you could make
  it clearer.

  Section 4.2 is the worst section of the paper – it says virtually
  nothing!  We learn that there is something “special” called a
  “permutation block”, but you do not motivate the need for such a
  block, nor explain its practical purpose.   All you really say is that
  there is a special permutation called…the identity permutation!  During
  the rest of the paper you do not seem to mention special blocks again,
  except that you refer to the identity permutation.  But surely there must
  be more to these blocks than the identity.  What is so “special”
  about them?

  I think the first few paragraphs of 5.3 logically belong in 5.2, as they
  appear to be about rules rather than combinators.  From “The most
  frequently used combinatory…” should be in Section 5.3, but the
  earlier stuff should be moved into 5.2.

  In Section 5.3 you refer twice to Figure 5.3 – something’s gone wrong
  here.

  Section 5.4 should be omitted.  All you are saying here is that you can
  use a name for convenience: just say this in one sentence, don’t waste
  the space of a whole subsection on it.  Instead, use the space to give
  more compelling examples as to why your method can be useful.

  In Section 5.5 it would be more convincing if you gave an example of a
  reduction that would be useful in GPU programming.  Also, it is not
  necessarily clear that intToFloat;floatToInt should compose to give the
  identity.  If you cast an int to a float you may get a rounding error.
  Of course, you may here be talking about a reinterpret cast: it’s not
  clear.

  Section 6.1: “For convenience … appropriate way” – remove this.
  These features are not for convenience – without them the tool simply
  would not be doing its job.  Correctly managing an internal set of
  temporary variables is standard for any translation tool; these kind of
  implementation details are really not worth mentioning (once again, use
  the space for something more convincing).

  Section 7 is the best section in the paper.  The example is useful – it
  gives a more concrete idea of what you are doing.  If you rewrite the
  paper I would suggest distributing this example through the paper –
  make it a running example.

  However, this example alone is not enough to convince me of the
  usefulness of your technique.  The optimization your method affords is
  pretty straightforward: it would be very easy for a GPU programmer to do
  this optimization by hand.  I would be more interested to see a use of
  your rewriting approach that would lead to an optimization that would be
  tricky and error prone to do by hand.

  You say “to the programmer, runKernel appears to simply perform a
  function on a local array” – this is not really true.  In CUDA or
  OpenCL, the programmer needs to actually write the body of the kernel
  function.  This body will have to manipulate shared and local memory, and
  use barriers for synchronization.  All your method has done here is
  slightly simplify the boilerplate code the programmer would have to
  write.  (And they still have to write some of it, as the code generation
  part of their rules.)

  In Figure 8, I think in the “copyFromGPU” rule it should say
  “cudaMemcpyDeviceToHost”.


------------------------ Submission 169, Review 3 ------------------------

Title: A Type-based Approach to Separating Protocol from Application Logic: A Case Study in Hybrid Computer Programming

Reviewer:           external
Overall rating:     8  (scale is 3..15; 15 is best)

Overall Rating

  2  (Probably reject: I would argue for rejecting this paper.)

Novelty

  2  (Somewhat novel)

Importance

  4  (Significantly important)

Expertise

  3  (Knowledgeable)

The Review

  The paper presents Twig, a programming system in which location of data
  is encoded in the type of the data, and the computation is expressed as
  typed rules that transform the data. Twig uses term rewriting to optimize
  the program and generates code without redundant data movements.

  It is unclear to me what the authors categorize as protocol logic. From
  reading the paper, the only thing that comes across is, data movement
  between memories is the only one in that category. The paper doesn't
  present optimizing anything else other than data movement. Either the
  authors can give more examples of 'protocol' tasks, or they should tone
  down the generality they claim in the paper.

  Here are some miscellaneous questions.

  * When is a 'left-biased choice' useful?
  * What is an example of a reduction rule that can optimize something
  other than data movement?
  * I don't understand why Twig cannot handle cyclical rules. Can't it
  recognize cyclical rules and warn the user even before applying them?

------------------------ Submission 169, Review 4 ------------------------

Title: A Type-based Approach to Separating Protocol from Application Logic: A Case Study in Hybrid Computer Programming

Reviewer:           secondary
Overall rating:     6  (scale is 3..15; 15 is best)

Overall Rating

  2  (Probably reject: I would argue for rejecting this paper.)

Novelty

  2  (Somewhat novel)

Importance

  2  (Somewhat important)

Expertise

  3  (Knowledgeable)

The Review

  This paper gives an overview of Twig, a programming system which aims to
  use an augmented type system, coupled with syntactic rewriting rules, to
  generate OpenCL code starting from a higher-level description of a
  computation.  The problem is important, and I felt the writing was clear.
   In general, I like the idea of using the type system to generate code,
  and think it has a lot of promise for heterogeneous parallel programming.
   However, the paper did not convince me that this particular approach
  offers any unique benefits or compelling results.

  Firstly, the authors do not show any non-trivial examples which would
  illustrate the utility of this work.  Can this system be used to solve
  difficult problems which OpenCL programmers have trouble with?  Can it
  provide good performance, compared to hand-written OpenCL code, but with
  higher programmer productivity?

  One high level question for the authors: is it really more productive for
  programmers to express their computation in two (somewhat) orthogonal
  ways: the Twig description and then the template code which will be
  assembled to form the program?  If the authors had used a unified system,
  with one type system, and one syntactic form, that might be easier for
  programmers.  For example, it is probably possible to use C++'s
  extensible type system along with metaprogramming to accomplish the same
  task, but with a simpler interface.

  Ultimately, this paper, although interesting, does not convince the
  reader that the work it presents is important.  More involved examples
  illustrating the power of this approach would strengthen the paper, since
  the rewriting rules themselves are fairly straightforward.
