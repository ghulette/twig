%!TEX root = twig-gpu.tex

\section{Twig's Semantics}
\label{sec:semantics}

Twig is based on a core semantics for term rewriting called System S\cite{system-s}, augmented with code generation and specialized to operate on types instead of general terms. Twig uses the operators in System S to combine primitive \emph{rules} into more complex transformations on types. These transformations are then applied to a given type, resulting in a new type and potentially generating code as a side effect. In this section we describe the Twig language.

We present an abbreviated and relatively informal description of Twig's semantics, focusing on the features used to support GPU programming. The full semantics will be described in a forthcoming paper.

You may notice that Twig does not currently provide any built-in constructs for expressing general recursive expressions, including loops. We are working to address this limitation in our current work. At the moment, Twig can generate loops contained within a single generated block and, of course, Twig can also be used to generate a block of code for inclusion within a loop body.

\subsection{Values}

Values in Twig can be any valid \emph{term} representing a type in the target language. Terms are tree structured data with labeled internal nodes. Examples of terms include simple values like \texttt{int} and \texttt{float}, as well as compound types like \texttt{ptr(int)}, which might represent a pointer to an integer in C.

The mapping between terms in Twig and types in the target language is a configuration option. Furthermore, the mapping need not be injective, i.e. users are free to have multiple values in Twig map to the same type in C. For example, you might use distinct Twig values \texttt{string} and \texttt{ptr(char)}, but map both to a pointer to \texttt{char} (\texttt{char *}) in C.

Twig also includes support for terms representing groups of values, i.e. \emph{tuples}, and operations on groups. We omit these semantics here for lack of space.

\subsection{Rules}
\label{sec:rules}

The fundamental components of a Twig program are called \emph{primitive rules}. A primitive rule describes a transformation from one term to another. For example, in C it is easy to convert an integer value to floating point, and we can write this rule in Twig as follows:

\begin{verbatim}
[int -> float]
\end{verbatim}

The term to the left of the arrow is the input, and the term to the right is the output. In this example, the rule says that if and only if the input to the rule is the term \texttt{int}, then the output will be the term \texttt{float}. If the input is not \texttt{int}, then the output will be the special value $\bot$, which can be read as ``undefined'' or ``failure.''

Primitive rules will typically generate code as a side effect of successful application. To associate a block of code with a rule, the programmer puts it immediately after the rule definition and surrounds it with braces. The brace symbols are configurable; here we use \texttt{<|} and \texttt{|>}. For example:

\begin{verbatim}
[int -> float] <| $out = (float)$in; |>
\end{verbatim}

When the code is generated, Twig will create temporary variables for \texttt{\$in} and \texttt{\$out} and ensure that the various bookkeeping details, such as variable declarations, are handled. If there are multiple inputs or outputs, then the relevant placeholders are enumerated; e.g., \texttt{\$in1}, \texttt{\$in2}, and so on.

Note that Twig does not check the generated code for correctness  -- the generation procedure is essentially syntactic. This approach is similar to the strategy used tools such as SWIG\cite{swig}.

\subsection{Formal semantics}

In the following formal semantics, let $t$ range over terms, $m$ over code block expressions, and $s$ over rule expressions, i.e., a primitive rule or a sub-expression built with operators.

\subsubsection{Primitive rules.}

A primitive rule $s$ transforms a term $t$ to another term $t'$ with generated code $m$:

\[
t \arr{s} (t',m)
\]

if the application of rule $s$ to value $t$ succeeds. If no code is given for the rule, then $m$ is the identity element, $I$ (see Sec.~\ref{sec:code-gen}). If the application of $s$ to $t$ fails, e.g., if $t$ does not match the pattern in $s$, then

\[
t \arr{s} \bot
\]

Note that a code block is not emitted in this case.

\subsubsection{Operators.}

Rules can be combined into more complex expressions using operators. The most useful of these is the \emph{sequence} operator (note the distinction from the $+$ operator for code blocks described in Sec.~\ref{sec:code-gen}). A sequence chains the application of two rules together, providing the output of the first to the input of the second, and failing if either rule fails (see Fig.~\ref{fig:twig-seq}). With this operator, simple rules can be composed into multi-step transformations.

\begin{figure}[ht]
\[
\infer{t \arr{s_1;s_2} (t'',m_1+m_2)}{t \arr{s_1} (t',m_1) \quad t' \arr{s_2} (t'',m_2)}
\qquad 
\infer{t \arr{s_1;s_2} \bot}{t \arr{s_1} \bot}
\qquad
\infer{t \arr{s_1;s_2} \bot}{t \arr{s_1} (t',m) \quad t' \arr{s_2} \bot}
\]
\caption{Semantics for sequence operator}
\label{fig:twig-seq}
\end{figure}

Another important operator is \emph{left-biased choice}. Choice expressions will try the first rule expression, and if it succeeds then its output is the result (see Fig.~\ref{fig:twig-choice}) of the expression. If the first rule fails (i.e., results in $\bot$), then the second rule is tried. This operator allows different paths to be taken, and different code to be generated, depending on the input type.

\begin{figure}[ht]
\[
\infer{t \arr{s_1|s_2} (t',m)}{t \arr{s_1} (t',m)}
\qquad 
\infer{t \arr{s_1|s_2} (t',m)}{t \arr{s_1} \bot \quad t \arr{s_2} (t',m)}
\qquad
\infer{t \arr{s_1|s_2} \bot}{t \arr{s_1} \bot \quad t \arr{s_2} \bot}
\]
\caption{Semantics for left-biased choice}
\label{fig:twig-choice}
\end{figure}

Fig.~\ref{fig:twig-basic} gives the formal semantics for some of Twig's other basic operators. These include constant operators and operators which discard their results.

\begin{figure}[ht]
\[
\infer{t \arr{\mathtt{id}} (t,I)}{}
\qquad
\infer{t \arr{\mathtt{fail}} \bot}{}
\qquad
\infer{t \arr{?s} (t,I)}{t \arr{s} (t',m)}
\qquad 
\infer{t \arr{?s} \bot}{t \arr{s} \bot}
\qquad
\infer{t \arr{\lnot s} \bot}{t \arr{s} (t',m)}
\qquad 
\infer{t \arr{\lnot s} (t,I)}{t \arr{s} \bot}
\]
\caption{Semantics for basic operators}
\label{fig:twig-basic}
\end{figure}

Twig also provides some special operators for tuples. These are not needed for this paper, so we omit further discussion.

\subsubsection{Named expressions.}
\label{sec:names}

Twig allows rules and rule expressions to be assigned to names. The name can be used in place of the rule itself within expressions. For example:

\begin{verbatim}
intToFloat = [int -> float] { ... }
\end{verbatim}

A Twig program is a list of such name/expression assignments. There is a special name, \texttt{main}, which designates the top-level expression for the program.

\subsection{Reductions}
\label{sec:reductions}

Reductions are a mechanism provided within Twig as a way to automatically simplify expressions. Reductions can be used to exploit application or domain knowledge about primitive rules, and as such are usually developed alongside a set of rules.

As an example, consider the following two rules:

\begin{verbatim}
intToFloat = [int -> float] {
  $out = (float)$in;
}

floatToInt = [float -> int] {
  $out = (int)$in;
}
\end{verbatim}

and the expression

\begin{verbatim}
intToFloat;floatToInt
\end{verbatim}

Probably, we would want to consider this conversion to be redundant and, if we encounter it, eliminate it. We can tell Twig to do this with the following reduction rule:

\begin{verbatim}
reduce intToFloat;floatToInt => id
\end{verbatim}

This statement instructs Twig to replace any subexpression \texttt{intToFloat;floatToInt} with the identity rule, \texttt{id}, anywhere it occurs within the program. Recall that \texttt{id} is the identity rule; it simply passes the value through unchanged.

Twig comes equipped with some standard reductions by default. These reductions rely on the meaning of Twig's combinators to normalize expressions. For example, we can replace subexpressions of the form \texttt{id;X} with \texttt{X}, where \texttt{X} represents any subexpression.

% Reductions must be developed carefully to avoid infinite loops. This can be surprisingly easy to do accidentally, even with simple rules. For example, Twig's evaluation will not terminate if it is given these two reductions
% 
% \begin{verbatim}
% reduce foo;bar => baz
% reduce baz => foo;bar
% \end{verbatim}
% 
% and one or both apply within the program. Twig will continually rewrite \texttt{foo;bar} to \texttt{baz}, and then back again, ad infinitum.

Twig's reductions are based on the theory of term rewriting; for a formal discussion see\cite{baader98rewriting}. In this case, Twig's expressions constitute the terms. There are some subtleties with reductions, e.g., they must be developed carefully to avoid circular reductions.
