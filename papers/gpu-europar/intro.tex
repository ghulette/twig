%!TEX root = twig-gpu.tex

\section{Introduction}

Programming for hybrid architectures is a challenging task, in large part due to the partitioned memory model they impose on programmers. Unlike a basic SMP, devices must be set up and torn down, processing synchronized, and data explicitly allocated on a particular device and moved around within the memory hierarchy. Programming systems such as CUDA\cite{cuda} and OpenCL\cite{opencl} provide an interface for these operations, but they are quite low-level. In particular, they do not distinguish between the high-level computational and application logic of a program, and the \emph{protocol logic} related to managing heterogeneous devices. As a result, the different types of program logic invariably become entangled, leading to excessively complex software that is prohibitively difficult to develop, maintain, and compose with other software. The problem we have described is pervasive in programming for hybrid architectures; in this paper, we will focus on the specific instance of this problem presented by GPU-based accelerators.

We present a high-level programming language called \emph{Twig}, designed for expressing protocol logic and separating it from computational and application logic. Twig also  supports automated reasoning about composite programs that can, in many cases, avoid problems such as redundant memory copying. This allows Twig programs often to retain the high performance of a lower-level programming approach.

Crucially, Twig's role in the programming toolchain is to generate code in a mainstream language, such as C. The generated code is easily incorporated into the main program, which is then compiled as usual. This minimizes the complexity that Twig adds to the build process, and allows Twig code to interact easily with existing code and libraries.

Twig achieves these goals by using data types to direct the generation of code in the target language. In particular, we augment existing data types in the target language with a notion of \emph{location}, e.g., an array of floats located on a GPU, or an integer located in main memory. In the following sections, we first present related work, and then describe Twig's code generation strategy and core semantics. Finally, we present an example demonstrating the use of located types to generate code for a GPU. In the example, we also show how Twig programs can be automatically rewritten in order to minimize data movement.
