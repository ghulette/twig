%!TEX root = twig-language.tex

\section{Twig}
\label{sec:semantics}

Twig is based on a core semantics called \emph{System S}~\cite{system-s}, originally designed for specifying term rewriting systems~\cite{baader98rewriting}. In Twig, we use the operators of System S to combine primitive \emph{rules} into more complex transformations on types. These transformations are then applied to a given type, which performs the transformation. We extend the semantics of System S in order to have the evaluation of the transformation generate code as a side effect. In this way, domain specific code can be generated depending on the input types. In this section we describe the basics of Twig's language.

\subsection{Values}

Values in Twig can be any valid \emph{term}. Terms are tree structured data with labeled internal nodes. Examples of terms include simple values like \texttt{int} and \texttt{float}, as well as compound types like \texttt{ptr(int)}, which represents a pointer to an integer. More complicated terms may involve multiple child terms, and may be nested to any depth. For example, \texttt{struct(int,float,struct(ptr(char)))} can represent a structure with three fields: an \texttt{int}, a \texttt{float}, and a second structure with a single string \texttt{char} pointer field.

The mapping between terms in Twig and types in the target language is considered to be a configuration option, controllable by the programmer. Furthermore, the mapping need not be injective, i.e., multiple values in Twig may map to the same type in C. For example, you might use distinct Twig values \texttt{string} and \texttt{ptr(char)}, but map both to a \texttt{char} pointer in C.

Twig has just one special kind of term: tuples. Tuples are represented as a set of sub-terms with either a special constructor \texttt{tuple}, or equivalently (and preferably) with no constructor at all. For example, \texttt{(string,int)} is the same as \texttt{tuple(string,int)}), and represents a pair of two types (a \texttt{string} and an \texttt{int}). The \texttt{tuple} constructor syntax is more verbose, so we typically eschew it in practice; however, it is convenient for our presentation of the formal semantics for tuple operators below.

\subsection{Rules}

% Formalize this section.

The basic building blocks of a Twig program are called \emph{primitive rules}. A primitive rule describes a transformation from one term to another. For example, in C it is easy to convert an integer value to floating point, and we can write this rule in Twig as follows:

\begin{verbatim}
[int -> float]
\end{verbatim}

The term to the left of the arrow is the input, and the term to the right is the output. In this example, the rule says that if the input value is \texttt{int} then it will be rewritten to the value \texttt{float}. If the input is not \texttt{int} then it will be rewritten to the distinguished value $\bot$, which can be read as ``undefined'' or simply ``failure.''

Rules can also have \emph{variables} in place of terms or sub-terms. For example the rule

\begin{verbatim}
[ptr(X) -> X]
\end{verbatim}

rewrites any pointer type to its referent. The variable \texttt{X} is bound to the corresponding value of the matched input on the right, and that value is then substituted for the variable where it appears on the left. Variables match whole sub-terms only; e.g., rules such as \texttt{[X(int) -> X]} are invalid.

Finally, primitive rules may generate code as a side effect of successful application. To include code with a rule, you put it immediately after the rule definition and surround it with braces, like so:

\begin{verbatim}
[int -> float] {
  $out = (float)$in;
}
\end{verbatim}

As part of the code generation, Twig will assign \texttt{\$in} and \texttt{\$out} elements generated C variable names, and ensure that they are declared with the appropriate type. If there are multiple inputs or outputs, then the relevant placeholders are enumerated; e.g., \texttt{\$in1}, \texttt{\$in2}, and so on.

It is important to understand that Twig does not check the code in any way, and the generation procedure is strictly syntactic. This scheme is similar to that used by SWIG~\cite{swig}.

\subsection{Combinators}

Rules can be combined into more complex expressions using Twig's operators. In the formal semantics, let $t$ range over terms, $m$ range over code expressions and $s_i$ range over rule expressions (i.e. a primitive rule, or another rule expression built with operators).

A primitive rule $s$ transforms $t$ to $t'$ with generated code $m$:

\[
t \arr{s} (t',m)
\]

if the application of rule $s$ to value $t$ succeeds. If no code is given for the rule, then $m$ is the ``no-op'' element, $e$. If the application of $s$ to $t$ fails, e.g., if $t$ does not match the pattern in $s$, then we say

\[
t \arr{s} \bot
\]

Note that no code is generated in this case.

The most important of Twig's combinators is the \emph{sequence} operator, which chains the application of two rules together, providing the output of the first to the input of the second, and failing if either rule fails (see Figure~\ref{fig:seq}). With this operator, simple rules can be composed into multi-step transformations.

\begin{figure}[ht]
\label{fig:seq}
\[
\infer
  {t \arr{s_1;s_2} (t'',m_1+m_2)}
  {t \arr{s_1} (t',m_1) \quad t' \arr{s_2} (t'',m_2)}
\qquad
\infer
  {t \arr{s_1;s_2} \bot}
  {t \arr{s_1} \bot}
\qquad
\infer
  {t \arr{s_1;s_2} \bot}
  {t \arr{s_1} (t',m) \quad t' \arr{s_2} \bot}
\]
\caption{Semantics for sequence operator}
\end{figure}

Another important binary operator is \emph{left-biased choice}. This operator will try the first rule expression, and if it succeeds then its output is the result (see Figure~\ref{fig:choice}). If it fails (i.e. results in $\bot$), then the second rule is tried. This operator allows different paths to be taken, and different code to be generated, depending on the input type being passed.

\begin{figure}[ht]
\label{fig:choice}
\[
\infer
  {t \arr{s_1|s_2} (t',m)}
  {t \arr{s_1} (t',m)}
\qquad 
\infer
  {t \arr{s_1|s_2} (t',m)}
  {t \arr{s_1} \bot \quad t \arr{s_2} (t',m)}
\qquad
\infer
  {t \arr{s_1|s_2} \bot}
  {t \arr{s_1} \bot \quad t \arr{s_2} \bot}
\]
\caption{Semantics for left-biased choice}
\end{figure}

Figure~\ref{fig:basic} gives the formal semantics for Twig's other operators, such as constant operators, and operators which discard their results.

\begin{figure}[ht]
\label{fig:basic}
\[
\infer
  {t \arr{\mathtt{id}} (t,I)}
  {}
\qquad
\infer
  {t \arr{\mathtt{fail}} \bot}
  {}
\]

\[
\infer
  {t \arr{?s} (t,I)}
  {t \arr{s} (t',m)}
\qquad 
\infer
  {t \arr{?s} \bot}
  {t \arr{s} \bot}
\qquad
\infer
  {t \arr{\lnot s} \bot}
  {t \arr{s} (t',m)}
\qquad 
\infer
  {t \arr{\lnot s} (t,I)}
  {t \arr{s} \bot}
\]
\caption{Semantics for basic operators}
\end{figure}

Twig also provides some special operators for tuples. The semantics in Figure~\ref{fig:all-tuples} apply to all the tuple operators, and state simply that tuple operators will fail if the input term is not a tuple, or if the rule references a tuple element out of bounds.

\begin{figure}[ht]
\label{fig:all-tuples}
\[
\infer
  {f(\ldots) \arr{s} \bot}
  {f \neq \mathtt{tuple}}
\qquad
\infer
  {\mathtt{tuple}(t_1,\ldots,t_n) \arr{s(i)} \bot}
  {i > n}
\]
\caption{Common semantics for tuple operators}
\end{figure}

One important tuple operator is \emph{congruence}, which applies a tuple of rules to a tuple of values, and returns a tuple of results or failure if any one rule application fails. The semantics are given in Figure~\ref{fig:congruence}.

\begin{figure}[ht]
\label{fig:congruence}
\[
\infer
  {\mathtt{tuple}(t_1,\ldots,t_n)\arr{(s_1,\ldots,s_n)} (\mathtt{tuple}(t_1',\ldots,t_n'),m_1 \times \ldots \times m_n) }
  {t_1 \arr{s_1} (t_1',m_1) \quad \ldots \quad t_n \arr{s_n} (t_n',m_n)}
\]
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots)\arr{(\ldots,s_i,\ldots)}\bot}
  {t_i \arr{s_i} \bot}
\]
\caption{Semantics for congruence operator}
\end{figure}

The \emph{branch} operator on tuples applies a tuple of rules to a single term, and produces a tuple of results with one element per rule. The branch operator has several semantic variants; we present one in Figure~\ref{fig:branch} wherein the branch operation fails if any single rule fails. We elide the other semantics, as well as the \emph{map} operator, which are similar in principle.

\begin{figure}[ht]
\label{fig:branch}
\[
\infer
  {t \arr{\mathtt{\#branch}(s_1,\ldots,s_n)} (\mathtt{tuple}(t_1',\ldots,t_n'),I_n + (m_1 \times \ldots \times m_n))}
  {t \arr{s_1} (t_1',m_1) \quad \ldots \quad t \arr{s_n} (t_n',m_n)}
\]
\[
\infer
  {t \arr{\mathtt{\#branch}(\ldots,s_i,\dots)} \bot}
  {t \arr{s_i} \bot}
\]
\caption{Semantics for branch operator}
\end{figure}

Finally, we have the \emph{projection} operator which extract a single element from a tuple, and its close relative, the \emph{path} operator, which applies a rule to a single element. The semantics are given in Figure~\ref{fig:projection} and Figure~\ref{fig:path}.

\begin{figure}[ht]
\label{fig:projection}
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i} (t_i,\Pi_{\{i\}})}
  {}
\]
\caption{Semantics for projection operator}
\end{figure}


\begin{figure}[ht]
\label{fig:path}
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} (\mathtt{tuple}(\ldots,t_i',\ldots), I_1 \times \ldots \times m \times \ldots \times I_1)}
  {t_i \arr{s} (t_i',m)}
\]
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} \bot}
  {t_i \arr{s} \bot}
\]
\caption{Semantics for path operator}
\end{figure}

\subsection{Expression names}
\label{section:names}

For convenience, Twig allows rules and rule expressions to be assigned names, like so:

\begin{verbatim}
intToFloat = [int -> float] {
  $out = (float)$in;
}
\end{verbatim}

This assigns a primitive rule to the name \texttt{intToFloat}. Names must begin with lower-case letters, and can only be used once. Now that name can be used in place of the rule itself in expressions, like this:

\begin{verbatim}
pairOfIntsToFloats = (intToFloat,intToFloat)
\end{verbatim}

A Twig program is a list of such name/expression assignments. There is a special expression name, \texttt{main}, which designates the top-level expression for the program.

\subsection{Integration with C}
\label{twig:concrete-code-gen}

Twig is capable of generating any procedural language, but in practice implementations must take the target language into account. Our current implementation of Twig is targeted to generate C code. For convenience, our implementation will handle tasks such as declaring variables, generating unique names, and ensuring that for sequencing blocks the outputs are assigned to the inputs in the appropriate way.

Optionally, generated code may be wrapped in a C function body, with parameters corresponding to the inputs, and return value corresponding to the output. In this case, Twig insists that the code block have a non-tuple output type, since C functions cannot return multiple values.
