%!TEX root = twig-language.tex

\section{Twig}
\label{sec:semantics}

Twig is based on a core semantics called \emph{System S}~\cite{system-s}, originally designed as a core language for term rewriting systems~\cite{baader98rewriting}. In Twig, we use the operators of System S to combine primitive \emph{rules} into more complex transformations on types. These transformations are then applied to a given type, which performs the transformation. We extend the semantics of System S in order to have the evaluation of the transformation generate code as a side effect. In this way, domain specific code can be generated depending on the input types. Our semantics are inspired by and are quite similar to those in Fig~\cite{fig}, but we have extended the rules to accomodate our code generation model. In this section we describe the semantics of Twig's language.

\subsection{Values}

Values in Twig are tree structured data with labeled internal nodes, called \emph{ground terms}. Formally, we say that a ground term $t$ is

\[
t \;\mbox{:=}\; c \;|\; f(t_1,\ldots,t_n)
\]

where $c$ is a \emph{constant}, and $f$ is a \emph{constructor} used to build terms from $n$ other terms. Constants and constructors can be any string of characters (except the special string ``tuple'' for reasons described below). The meaning of constants and constructors is left mostly abstract -- they are defined by their use in the program's \emph{rules}, described below. We call the set of all terms $T$.

For typemapping, terms are typically used to represent types in some other language. For example, we use constant terms, such \texttt{int} and \texttt{float} to represent primitive types in C. More complicated terms can be used to represent types with structure, e.g., \texttt{ptr(int)} can represent a C pointer to an integer. More complicated terms may involve multiple child terms, and may be nested to any depth. For example, \texttt{struct(int,float,struct(ptr(char)))} may represent a structure with three fields: an \texttt{int}, a \texttt{float}, and a second structure with a single string (pointer to \texttt{char}) field.

The mapping between terms in Twig and types in the target language is considered to be a configuration option, controllable by the user and customizable to the domain. Furthermore, the mapping need not be injective, i.e., multiple terms in Twig may map to the same type in C. For example, you might use distinct Twig values \texttt{string} and \texttt{ptr(char)}, but map both to a \texttt{char} pointer in C.

Twig has just one special kind of structured term: tuples. Tuples may have any length, and the elements of the tuple are represented as the sub-terms of a term with a special constructor: \texttt{tuple}. Twig's syntax also equates the absense of any constructor with the presence of the \texttt{tuple} constructor. For example, the syntax \texttt{(string,int)} is interpreted as the \texttt{tuple(string,int)}. This term represents a tuple of length two, whose first element is \texttt{string} and whose second element is \texttt{int}. The \texttt{tuple} constructor syntax is more verbose, so we typically will eschew it in practice; it is convenient, however, for our presentation of the formal semantics below.

\subsubsection{Tuple ``size'' versus ``width''}

The \emph{size} of a tuple is simply the cardinality of its children. We will sometimes write $\mathtt{tuple}_n(\ldots)$ to indicate a tuple of length $n$, where the length is not otherwise clear from the context.

One small complication arises because we permit tuples to be nested to arbitrary depth. For example the term

\[
\mathtt{tuple(tuple(int,float),tuple(double))} 
\]

is a valid tuple with a nesting depth of two. In some of our semantics, we need to provide a \emph{width} of a tuple, defined as 

\[
\mbox{width}(t) = \left\{
  \begin{array}{cl}
    \sum^{i=1}_{n} \mbox{width}(t_i) 
      & \mbox{if } t = \mathtt{tuple}(t_1,\ldots,t_n)\vspace{2mm}\\
    1 & \mbox{otherwise}
  \end{array}
\right.
\]

Intuitively, the width of a tuple corresponds to the size of its ``flattened'' version -- where the elements of nested tuples are pushed up, recursively, to the top level. If we flattened the tuple in the example above, we would get

\[
\mathtt{tuple(int,float,double)}
\]

and so its width would be three.

\subsection{Expressions}

Programs in Twig are \emph{expressions}, which can be either \emph{primitive rules} (desribed in  Section~\ref{sec:semantics:prims}) or else built from other expressions using Twig's operators (Section~\ref{sec:semantics:ops}). An expression $s$ is a function from terms $T$ to elements of the set $(T \times M) \cup \{\bot\}$, i.e., either a pair $(t',m)$ where $t' \in T$ and $m$ is a \emph{block} in the set $M$ (described in Section~\ref{sec:code-gen}) or else the special, distinguished value $\bot$. Formally,

\[
s : T \to ((T \times M) \cup \{\bot\})
\]

In this context, we use $\bot$ to denote ``failure.'' In particular, we make use of $\bot$ as a special value in the semantics for Twig's operators, as described in Section~\ref{sec:semantics:ops}.

In the remainder of this section we explore the ways in which we can construct expressions.

\subsection{Primitive Rules}
\label{sec:semantics:prims}

The simplest Twig expression is called a \emph{primitive rule}.
Primitive rules describe a single transformation step. Since
Twig's terms represent types in a target language, a primitive
rule in Twig describes how to transform an instance of one type
into an instance of another in that language.

For example, in C it is easy to convert an integer value to
floating point. Twig's syntax for writing this rule is as follows:

\begin{verbatim}
[int -> float]
\end{verbatim}

The term to the left of the arrow is the \emph{input pattern}, and the term to the right is the \emph{output pattern}. In this example, the rule says that if the input to the expression \emph{matches} the term \texttt{int}, then the output of the expression will be the term \texttt{float} (along with a code block, discussed below). If the input term does not match \texttt{int} then the output will be $\bot$.

Rules can also have \emph{variables} in place of terms or sub-terms. For example the rule

\begin{verbatim}
[ptr(X) -> X]
\end{verbatim}

describes a transformation of any C pointer type to its referent. The variable \texttt{X} is bound to the corresponding value of the matched input on the right, and that value is then substituted for the variable where it appears on the left. Variables may stand in place of terms only, not constructors; e.g., rules such as \texttt{[X(int)~->~X]} are invalid.

When an input term is \emph{matched}, we mean that it is unified~\cite{baader98rewriting} with the input pattern. In the formal semantics in Section~\ref{sec:semantics:ops}, if a term $t$ matches the input pattern of a rule $s$, the proposition $\mbox{match}(t,s)$ is true. Otherwise, it is false. We omit further formalization of matching here for lack of space; see \cite{baader98rewriting,system-s} for details.

In fact, Twig's matching algorithm is simpler than full unification, since there is no equational theory and the input term may not contain variables (i.e., must be a ground term). If unification is successful, we say that the term \emph{matched}. The bound variables (if any) are saved in order to construct the output term via substitution.

A primitive rule transforms $t$ to $t'$ with an associated block $m$ if and only if the application of rule to value $t$ succeeds. In this case we write $t \arr{s} (t',m)$. Otherwise, if the application of $s$ to $t$ fails, e.g., if $t$ does not match the input pattern in $s$, then we write $t \arr{s} \bot$.

Note that in this case, the block is not produced.

% Probably should talk about variable binding, e.g. how (X,X) will match a pair of identical terms.

\subsubsection{Blocks}

Primitive rules are associated with have a block. In Twig's syntax, blocks are surrounded by triple-angle braces and appear immediately after a primitive rule, like so:

\begin{verbatim}
[int -> float] <<<
  $out = (float)$in;
>>>
\end{verbatim}

The contents of the block depends on the target language; in this case, we have provided a block of escaped C code (as described in Section~\ref{sec:code-gen:c}). The target language must be specified as a parameter to the Twig runtime (in our current implementation, as a command line option). This means that the text between the \verb|<<<| and \verb|>>>| is interpreted based on the chosen block implementation. A target language specific procedure is passed the text, along with the input and output term(s). It can then construct the block however it sees fit. In our C block implementation, for example, variable names are generated and the terms are used to determine the appropriate types for declaring those variables in a prelude section of the code. Other target languages might choose very different block construction mechanisms.

It is important to understand that Twig's semantics do not require that block contents be checked in any way (although an implementation could do this), and that the code generation procedure is strictly syntactic. This scheme is similar to that used by SWIG~\cite{swig}.

\subsection{Operators}
\label{sec:semantics:ops}

Rules expressions can be combined using Twig's operators. In the formal semantics, we let $t$ range over terms, $m$ range over blocks and $s$ range over expressions (i.e., a primitive rule, or another expression built with operators).

The first and arguably most useful of Twig's combinators is the \emph{sequence} operator, written as an infix semi-colon (\texttt{;}). Sequencing chains the application of two rules together, sending the output of the first to the input of the second, and failing if either rule fails (see Figure~\ref{fig:seq}). With this operator, individual rules can be composed into multi-step transformations. Note how, upon success, the blocks are themselves composed in sequence.

\begin{figure}[ht]
\[
\infer
  {t \arr{s_1;s_2} (t'',m_1+m_2)}
  {t \arr{s_1} (t',m_1) \quad t' \arr{s_2} (t'',m_2)}
\]
\[
\infer
  {t \arr{s_1;s_2} \bot}
  {t \arr{s_1} \bot}
\qquad
\infer
  {t \arr{s_1;s_2} \bot}
  {t \arr{s_1} (t',m) \quad t' \arr{s_2} \bot}
\]
\caption{Semantics for sequence operator}
\label{fig:seq}
\end{figure}

Another important operator is \emph{left-biased choice}, written as a vertical bar (\texttt{|}). This operator will attempt to apply the first rule expression to the input, and if it succeeds then its output is the result (see Figure~\ref{fig:choice}). If it fails (i.e., results in $\bot$), then it attempts to apply the second rule instead. This operator allows different paths to be taken through the rules, and different code to be generated, depending on the input type being passed.

\begin{figure}[ht]
\[
\infer
  {t \arr{s_1|s_2} (t',m_1)}
  {t \arr{s_1} (t',m_1)}
\qquad
\infer
  {t \arr{s_1|s_2} (t',m_2)}
  {t \arr{s_1} \bot \quad t \arr{s_2} (t',m_2)}
\]
\[
\infer
  {t \arr{s_1|s_2} \bot}
  {t \arr{s_1} \bot \quad t \arr{s_2} \bot}
\]
\caption{Semantics for left-biased choice}
\label{fig:choice}
\end{figure}

Figure~\ref{fig:basic1} and Figure~\ref{fig:basic2} gives the formal semantics for Twig's other operators. Identity (\texttt{T}) will always succeed, returning its input and an identity block, failure (\texttt{F}) will always return \texttt{$\bot$}. Test (\texttt{?}) takes a single expression as a parameter and succeeds only if its argument succeeds, returning the original term. Negation \texttt{$\lnot$} also takes a single expression argument, and succeeds only if its argument fails, returning the original term.

\begin{figure}[ht]
\[
\infer
  {t \arr{\mathtt{T}} (t,I)}
  {}
\qquad
\infer
  {t \arr{\mathtt{F}} \bot}
  {}
\]
\caption{Semantics for Success (\texttt{T}) and Failure (\texttt{F})}
\label{fig:basic1}
\end{figure}

\begin{figure}[ht]
\[
\infer
  {t \arr{?s} (t,I)}
  {t \arr{s} (t',m)}
\qquad 
\infer
  {t \arr{?s} \bot}
  {t \arr{s} \bot}
\]
\[
\infer
  {t \arr{\lnot s} \bot}
  {t \arr{s} (t',m)}
\qquad 
\infer
  {t \arr{\lnot s} (t,I)}
  {t \arr{s} \bot}
\]
\caption{Semantics for Test (\texttt{?}) and Negation ($\lnot$)}
\label{fig:basic2}
\end{figure}

Twig also provides some special operators for tuples. For each of the tuple operators, there are some additional semantics that we have elided for lack of space. The omitted semantics simply state that any tuple operator will fail (i.e., return $\bot$) if the input term is not a tuple, or if the expression tries to reference a tuple element that is out of bounds.

% \begin{figure}[ht]
% \[
% \infer
%   {f(\ldots) \arr{s} \bot}
%   {f \neq \mathtt{tuple}}
% \qquad
% \infer
%   {\mathtt{tuple}(t_1,\ldots,t_n) \arr{s(i)} \bot}
%   {i > n}
% \]
% \caption{Common semantics for tuple operators}
% \label{fig:all-tuples}
% \end{figure}

One important tuple operator is \emph{congruence}, which applies a tuple of expressions to the elements of a tuple term, pairwise, and returns a tuple of results, or else failure in case any rule application fails. Upon success, the returned block is the parallel composition of the individual result blocks. The semantics for congruence are shown in Figure~\ref{fig:congruence}.

\begin{figure}[ht]
\[
\infer
  {\mathtt{tuple}(t_1,\ldots,t_n)\arr{(s_1,\ldots,s_n)} (\mathtt{tuple}(t_1',\ldots,t_n'),m_1 \times \ldots \times m_n)}
  {t_1 \arr{s_1} (t_1',m_1) \quad \ldots \quad t_n \arr{s_n} (t_n',m_n)}
\]
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots)\arr{(\ldots,s_i,\ldots)}\bot}
  {t_i \arr{s_i} \bot}
\]
\caption{Semantics for congruence operator}
\label{fig:congruence}
\end{figure}

The family of \emph{branch} operators on tuples applies a single rule to one, all, or some of the tuple's elements, depending on the variation. In Figure~\ref{fig:branch} we present the semantics for the case where the rule applies to a single element: the first element, from left to right, for which the rule application does not fail. The other elements of the tuple are passed through wherein the branch operation fails if any single rule fails. Note the branch operator's use of a fanout block, defined in Section~\ref{sec:code-gen:special}. We elide the semantics of the other branch operators for lack of space.

\begin{figure*}[ht]
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\mathtt{\#one}(s)} (\mathtt{tuple}(\ldots,t_i',\ldots),(I \times \ldots \times m_i \times \ldots \times I))}
  {t_i \arr{s} (t_i',m_i)}
\]
\[
\infer
  {\mathtt{tuple}(t_1,\ldots,t_n) \arr{\mathtt{\#one}(s)} \bot}
  {t_1 \arr{s} \bot \quad \ldots \quad t_n \arr{s} \bot}
\]
\caption{Semantics for branch-one operator}
\label{fig:branch}
\end{figure*}

Next, we have the \emph{projection} operator which extracts a single indexed element from a tuple, and its close relative, the \emph{path} operator, which applies a rule to a single indexed tuple element, leaving the other elements untouched. The semantics are given in Figure~\ref{fig:projection} and Figure~\ref{fig:path}.

\begin{figure}[ht]
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i} (t_i,\Pi(i))}
  {}
\]
\caption{Semantics for projection operator}
\label{fig:projection}
\end{figure}

\begin{figure}[ht]
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} (\mathtt{tuple}(\ldots,t_i',\ldots), I \times \ldots \times m_i \times \ldots \times I)}
  {t_i \arr{s} (t_i',m_i)}
\]
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} \bot}
  {t_i \arr{s} \bot}
\]
\caption{Semantics for path operator}
\label{fig:path}
\end{figure}

Finally, the \emph{permutation} operator allows arbitrary permutation of a tuple's elements, including duplicating or dropping elements. The semantics are given in Figure~\ref{fig:permute}. We provide a slightly specialized semantics when the permutation takes just one input -- in this case, we equate a 1-tuples and terms, which allows the permutation operator to duplicate single terms. This case is given in Figure~\ref{fig:permute-one}.

Building on this special case, we also provide a ``fan out'' operator. We define this operator in terms of the one input permutation operator, shown in Figure~\ref{fig:fan}.

\begin{figure*}[htb]
\[
\infer
  {\mathtt{tuple}(t_1,\ldots,t_n) \arr{\mathtt{\#permute}_n(x_1,\ldots,x_m)} (\mathtt{tuple}(t_{x_1},\ldots,t_{x_m}),\Pi_w(y_{x_1},\ldots,y_{x_m}))}
  {}
\]
\begin{eqnarray*}
w   &=& \sum_{j=1}^n \mbox{width}(t_i)\\
b_i &=& \left\{
  \begin{array}{cl}
    0 & \mbox{if } i = 1\\
    \sum_{j=1}^{i-1} \mbox{width}(t_i) & \mbox{if } i > 1
  \end{array}
\right.\\
y_i &=& b_i+1,\ldots,b_i + \mbox{width}(t_i)
\end{eqnarray*}
\caption{Semantics for permutation operator}
\label{fig:permute}
\end{figure*}

\begin{figure}[htb]
\[
\infer
  {t \arr{\mathtt{\#permute}_1(1,\overset{n}{\ldots},1)} (\mathtt{tuple}(t,\overset{n}{\ldots},t),\Pi_1(y,\overset{n}{\ldots},y))}
  {}
\]
\begin{eqnarray*}
y &=& 1,\ldots,\mbox{width}(t)
\end{eqnarray*}
\caption{Semantics for permute 1 operator}
\label{fig:permute-one}
\end{figure}


\begin{figure}[ht]
\[
\mathtt{\#fan}(n) \equiv \mathtt{\#permute}_1(\underbrace{1,\ldots,1}_\text{n})
\]
\caption{Semantics for fan operator}
\label{fig:fan}
\end{figure}


Twig also includes a fixed-point operator, allowing it to express rules for handling recursively defined data types. We have omitted the semantics for lack of space.


\subsection{Expression names}
\label{section:names}

Twig allows expressions to be named, like so:

\begin{verbatim}
intToFloat = [int -> float] <<<
  $out = (float)$in;
>>>
\end{verbatim}

This assigns a primitive rule to the name \texttt{intToFloat}. Names must begin with lower-case letters, and can only be used once. Now that name can be used in place of the rule itself in expressions, like this:

\begin{verbatim}
pairOfIntsToFloats = (intToFloat,intToFloat)
\end{verbatim}

A Twig program is a list of such name/expression assignments. There is a special expression name, \texttt{main}, which designates the top-level expression for the program.

% \subsection{Integration with C}
% \label{twig:concrete-code-gen}
% 
% Twig is capable of generating any procedural language, but in practice implementations must take the target language into account. Our current implementation of Twig is targeted to generate C code. For convenience, our implementation will handle tasks such as declaring variables, generating unique names, and ensuring that for sequencing blocks the outputs are assigned to the inputs in the appropriate way.
% 
% Optionally, generated code may be wrapped in a C function body, with parameters corresponding to the inputs, and return value corresponding to the output. In this case, Twig insists that the code block have a non-tuple output type, since C functions cannot return multiple values.
