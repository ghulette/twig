%!TEX root = twig-language.tex

\section{Twig}
\label{sec:semantics}

Twig is based on a core semantics called \emph{System S}~\cite{system-s}, originally designed for specifying term rewriting systems~\cite{baader98rewriting}. In Twig, we use the operators of System S to combine primitive \emph{rules} into more complex transformations on types. These transformations are then applied to a given type, which performs the transformation. We extend the semantics of System S in order to have the evaluation of the transformation generate code as a side effect. In this way, domain specific code can be generated depending on the input types. In this section we describe the semantics of Twig's language.

\subsection{Values}

Values in Twig can be any valid \emph{term}. Terms are tree structured data with labeled internal nodes. Examples of terms include simple values like \texttt{int} and \texttt{float}, as well as compound types like \texttt{ptr(int)}, which represents a pointer to an integer. More complicated terms may involve multiple child terms, and may be nested to any depth. For example, \texttt{struct(int,float,struct(ptr(char)))} may represent a structure with three fields: an \texttt{int}, a \texttt{float}, and a second structure with a single string ( pointer to \texttt{char}) field.

The mapping between terms in Twig and types in the target language is considered to be a configuration option, controllable by the user and customizable to the domain. Furthermore, the mapping need not be injective, i.e., multiple values in Twig may map to the same type in C. For example, you might use distinct Twig values \texttt{string} and \texttt{ptr(char)}, but map both to a \texttt{char} pointer in C.

Twig has just one special kind of term: tuples. Tuples may have any length, and the elements of the tuple are represented as the sub-terms of a term with a special constructor: \texttt{tuple}. Alternately, Twig's syntax considers the absense of any constructor to denote the \texttt{tuple} constructor. For example, the syntax \texttt{(string,int)} is interpreted as the term \texttt{tuple(string,int)}). This term represents a tuple of length two, whose first element is \texttt{string} and whose second element is \texttt{int}. The \texttt{tuple} constructor syntax is more verbose, so we typically will eschew it in practice; it is convenient, however, for our presentation of the formal semantics below.

\subsection{Expressions}

Programs in Twig take the form of \emph{rule expressions}. A rule expression $s$ acts upon a term $t$ in some given set of valid terms $T$. The result of applying $s$ to $t$ is always either ``failure,'' which we denote $\bot$, or else a pair $(t',m)$, where $t'$ is another term and $m$ is a \emph{block} in $M$, as described in Section~\ref{sec:code-gen}. Formally, we say that $s$ is a function

\[
s : T \to (T \times M) \cup \bot
\]

In the rest of this section we explore the ways in which we can construct rule expressions.

\subsection{Primitive Rules}

The simplest Twig expression is called a \emph{primitive rule}.  Primitive rules describe a single transformation step. Since Twig's terms represent types, a primitive rule in Twig describes how to transform an instance of one type into an instance of another.

For example, in C it is easy to convert an integer value to floating point, and we can write this rule in Twig as follows:

\begin{verbatim}
[int -> float]
\end{verbatim}

The term to the left of the arrow is the \emph{input pattern}, and the term to the right is the \emph{output pattern}. In this example, the rule says that if the input to the expression \emph{matches} \texttt{int}, then the output of the expression will be the value \texttt{float} (along with a code block, discussed below). If the input term does not match \texttt{int} then the output will be $\bot$.

Rules can also have \emph{variables} in place of terms or sub-terms. For example the rule

\begin{verbatim}
[ptr(X) -> X]
\end{verbatim}

transforms any pointer type to its referent. The variable \texttt{X} is bound to the corresponding value of the matched input on the right, and that value is then substituted for the variable where it appears on the left. Variables may stand in place of terms only, not constructors; e.g., rules such as \texttt{[X(int) -> X]} are invalid.

We must now make clear what we mean when we say that the input term \emph{matches} the input pattern. In effect, the input term is \emph{unified}\cite{baader98rewriting} with the input pattern. In fact, the algorithm used is simpler than ``full'' unification, since there is no equational theory and the input term may not contain variables (i.e., must be ground). If the unification is successful, we say that the term \emph{matched}. The bound variables (if any) are saved in order to construct the output term via substitution.

% Probably should talk about variable binding, e.g. how (X,X) will match a pair of identical terms.

\subsubsection{Blocks}

Primitive rules are associated with have a block. The block is constructed based on some target language-dependent text, which appears immediately after the rule definition and is surrounded by triple-angle brances, like so:

\begin{verbatim}
[int -> float] <<<
  $out = (float)$in;
>>>
\end{verbatim}

Block construction depends on the target language; in this case, we have provided a block of escaped C code (as described in Section~\ref{sec:code-gen:c}). The target language must be specified as a parameter to the Twig runtime (in our current implementation, as a command line option). This means that the text between the \verb|<<<| and \verb|>>>| is interpreted based on the chosen block implementation. A target langauge specific procedure is passed the text, along with the input and output term(s). It can then construct the block however it sees fit. In our C block implementation, for example, variable names are generated and the terms are used to determine the appropriate types for declaring those variables in a prelude section of the code. Other target languages might choose very different block construction mechanisms.

It is important to understand that Twig does not check the block code in any way (although the block implementation could), and that the code generation procedure is strictly syntactic. This scheme is similar to that used by SWIG~\cite{swig}.

\subsection{Operators}

Rules expressions can be combined using Twig's operators. In the formal semantics, we let $t$ range over terms, $m$ range over blocks and $s_i$ range over rule expressions (i.e., a primitive rule, or another expression built with operators).

A primitive rule $s$ transforms $t$ to $t'$ with an associated  block $m$:

\[
t \arr{s} (t',m)
\]

if the application of rule $s$ to value $t$ succeeds. If no code is given for the rule, then $m$ is the ``no-op'' element, $e$. If the application of $s$ to $t$ fails, e.g., if $t$ does not match the pattern in $s$, then we say

\[
t \arr{s} \bot
\]

Note that no block is emitted in this case.

The first and arguably most useful of Twig's combinators is the \emph{sequence} operator, which chains the application of two rules together, sending the output of the first to the input of the second, and failing if either rule fails (see Figure~\ref{fig:seq}). With this operator, individual rules can be composed into multi-step transformations. Note how, upon success, the blocks are themselves composed in sequence.

\begin{figure}[ht]
\label{fig:seq}
\[
\infer
  {t \arr{s_1;s_2} (t'',m_1+m_2)}
  {t \arr{s_1} (t',m_1) \quad t' \arr{s_2} (t'',m_2)}
\]
\[
\infer
  {t \arr{s_1;s_2} \bot}
  {t \arr{s_1} \bot}
\qquad
\infer
  {t \arr{s_1;s_2} \bot}
  {t \arr{s_1} (t',m) \quad t' \arr{s_2} \bot}
\]
\caption{Semantics for sequence operator}
\end{figure}

Another important operator is \emph{left-biased choice}. This operator will attempt to apply the first rule expression to the input, and if it succeeds then its output is the result (see Figure~\ref{fig:choice}). If it fails (i.e., results in $\bot$), then it attempts to apply the second rule instead. This operator allows different paths to be taken through the rules, and different code to be generated, depending on the input type being passed.

\begin{figure}[ht]
\label{fig:choice}
\[
\infer
  {t \arr{s_1|s_2} (t',m_1)}
  {t \arr{s_1} (t',m_1)}
\qquad
\infer
  {t \arr{s_1|s_2} (t',m_2)}
  {t \arr{s_1} \bot \quad t \arr{s_2} (t',m_2)}
\]
\[
\infer
  {t \arr{s_1|s_2} \bot}
  {t \arr{s_1} \bot \quad t \arr{s_2} \bot}
\]
\caption{Semantics for left-biased choice}
\end{figure}

Figure~\ref{fig:basic} gives the formal semantics for Twig's other operators. Identity (\texttt{id}) will always succeed, returning its input and an identity block, failure (\texttt{fail}) will always return \texttt{$\bot$}. Test (\texttt{?}) succeeds only if its single paramter expression succeeds, but it returns the original term. Negation \texttt{$\lnot$} succeeds only if its parameter expression fails, returning the original term.

\begin{figure}[ht]
\label{fig:basic}
\[
\infer
  {t \arr{\mathtt{id}} (t,I)}
  {}
\]
\[
\infer
  {t \arr{\mathtt{fail}} \bot}
  {}
\]
\[
\infer
  {t \arr{?s} (t,I)}
  {t \arr{s} (t',m)}
\qquad 
\infer
  {t \arr{?s} \bot}
  {t \arr{s} \bot}
\]
\[
\infer
  {t \arr{\lnot s} \bot}
  {t \arr{s} (t',m)}
\qquad 
\infer
  {t \arr{\lnot s} (t,I)}
  {t \arr{s} \bot}
\]
\caption{Semantics for basic operators}
\end{figure}

Twig also provides some special operators for tuples. The semantics in Figure~\ref{fig:all-tuples} apply to all of the following tuple operators, unless otherwise indicated. These semantics state that a tuple operator will fail if the input term is not a tuple, or if the rule tries to reference a tuple element that is out of bounds.

\begin{figure}[ht]
\label{fig:all-tuples}
\[
\infer
  {f(\ldots) \arr{s} \bot}
  {f \neq \mathtt{tuple}}
\qquad
\infer
  {\mathtt{tuple}(t_1,\ldots,t_n) \arr{s(i)} \bot}
  {i > n}
\]
\caption{Common semantics for tuple operators}
\end{figure}

One important tuple operator is \emph{congruence}, which applies a tuple of expressions to the elements of a tuple term, pairwise, and returns a tuple of results, or else failure in case any rule application fails. Upon success, the returned block is the parallel composition of the individual result blocks. The semantics for congruence are shown in Figure~\ref{fig:congruence}.

\begin{figure}[ht]
\label{fig:congruence}
\[
\infer
  {\mathtt{tuple}(t_1,\ldots,t_n)\arr{(s_1,\ldots,s_n)} (\mathtt{tuple}(t_1',\ldots,t_n'),m_1 \times \ldots \times m_n) }
  {t_1 \arr{s_1} (t_1',m_1) \quad \ldots \quad t_n \arr{s_n} (t_n',m_n)}
\]
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots)\arr{(\ldots,s_i,\ldots)}\bot}
  {t_i \arr{s_i} \bot}
\]
\caption{Semantics for congruence operator}
\end{figure}

The family of \emph{branch} operators on tuples applies a single rule to one, all, or some of the tuple's elements, depending on the variation. In Figure~\ref{fig:branch} we present the semantics for the case where the rule applies to a single element: the first element, from left to right, for which the rule application does not fail. The other elements of the tuple are passed through wherein the branch operation fails if any single rule fails. Note the branch operator's use of a fanout block, defined in Section~\ref{sec:code-gen:special}. We elide the semantics of the other branch operators for lack of space.

\begin{figure*}[ht]
\label{fig:branch}
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\mathtt{\#one}(s)} (\mathtt{tuple}(\ldots,t_i',\ldots),(I \times \ldots \times m_i \times \ldots \times I))}
  {t_i \arr{s} (t_i',m_i)}
\]
\[
\infer
  {\mathtt{tuple}(t_1,\ldots,t_n) \arr{\mathtt{\#one}(s)} \bot}
  {t_1 \arr{s} \bot \quad \ldots \quad t_n \arr{s} \bot}
\]
\caption{Semantics for branch-one operator}
\end{figure*}

Next, we have the \emph{projection} operator which extracts a single indexed element from a tuple, and its close relative, the \emph{path} operator, which applies a rule to a single indexed tuple element, leaving the other elements untouched. The semantics are given in Figure~\ref{fig:projection} and Figure~\ref{fig:path}.

\begin{figure}[ht]
\label{fig:projection}
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i} (t_i,\Pi(i))}
  {}
\]
\caption{Semantics for projection operator}
\end{figure}

\begin{figure}[ht]
\label{fig:path}
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} (\mathtt{tuple}(\ldots,t_i',\ldots), I \times \ldots \times m \times \ldots \times I)}
  {t_i \arr{s} (t_i',m)}
\]
\[
\infer
  {\mathtt{tuple}(\ldots,t_i,\ldots) \arr{\#i(s)} \bot}
  {t_i \arr{s} \bot}
\]
\caption{Semantics for path operator}
\end{figure}

Finally, the \emph{permutation} operator allows arbitrary permutation of a tuple's elements, including duplicating or dropping elements. The semantics are given in Figure~\ref{fig:permute}. We also define a special case ``fan out'' operator, which allow non-tuple terms to be duplicated.

\begin{figure}[ht]
\label{fig:permute}
\[
\infer
  {\mathtt{tuple}(t_1,\ldots,t_k) \arr{\#\mathtt{permute}_k(i_1,\ldots,i_n)} (\mathtt{tuple}(t_{i_1},\ldots,t_{i_n}),I)}
  {}
\]
\[
\infer
  {t \arr{\mathtt{\#fan(n)}} (\mathtt{tuple}(t,\ldots,t),I)}
  {}
\]

\caption{Semantics for permutation ($\&$) operator}
\end{figure}


\subsection{Expression names}
\label{section:names}

As a convenience, Twig allows rules and rule expressions to be named, like so:

\begin{verbatim}
intToFloat = [int -> float] <<<
  $out = (float)$in;
>>>
\end{verbatim}

This assigns a primitive rule to the name \texttt{intToFloat}. Names must begin with lower-case letters, and can only be used once. Now that name can be used in place of the rule itself in expressions, like this:

\begin{verbatim}
pairOfIntsToFloats = (intToFloat,intToFloat)
\end{verbatim}

A Twig program is a list of such name/expression assignments. There is a special expression name, \texttt{main}, which designates the top-level expression for the program.

% \subsection{Integration with C}
% \label{twig:concrete-code-gen}
% 
% Twig is capable of generating any procedural language, but in practice implementations must take the target language into account. Our current implementation of Twig is targeted to generate C code. For convenience, our implementation will handle tasks such as declaring variables, generating unique names, and ensuring that for sequencing blocks the outputs are assigned to the inputs in the appropriate way.
% 
% Optionally, generated code may be wrapped in a C function body, with parameters corresponding to the inputs, and return value corresponding to the output. In this case, Twig insists that the code block have a non-tuple output type, since C functions cannot return multiple values.
