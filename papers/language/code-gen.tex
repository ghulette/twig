%!TEX root = twig-language.tex

\section{Code generation}
\label{sec:code-gen}

One of our goals for Twig was that it be able to generate code in many different target languages. To that end, Twig's semantics rely on an abstract, language-independent model for code generation with a small number of basic operations. To incorporate a new target language, it suffices to implement only these operations. There is no need to modify the core Twig interpreter, which assumes nothing beyond the abstract model.

Our simplified code generation model is used in formulating Twig's core semantics, described in Section~\ref{sec:semantics}. It is also helpful in clarifying the precise operations which Twig supports, without getting bogged down in the (potentially rather complicated) details of outputting code for a particular target programming language.

In Section~\ref{sec:code-gen:abstract}, we describe the abstract code generation model, apart from any specific target programming language, including the formal semantics. Then, in Section~\ref{sec:code-gen:c} we show how we have used this model in order to generate C code.

\subsection{Abstract Code Generation}
\label{sec:code-gen:abstract}

In Twig, a unit of code to be generated is called a \emph{block}. Intuitively, a block represents some code in the target language, which accepts inputs and produces outputs. We denote the complete set of all blocks $M$, and provide functions 
$\mbox{in} : M \to \mathbb{N}$ and $\mbox{out} : M \to \mathbb{N}$ which map a block to the number of its inputs and to its outputs, respectively. Note that either or both may be zero for a given $x$.

\subsubsection{Sequential Composition}

The first of Twig's elementary block binary operations is called  \emph{sequential composition}, which we represent as ``addition'' on the elements of $M$, i.e. 

\[
+ : M \times M \to M
\]

Intuitively, sequencing represents connecting two blocks ``vertically,'' by feeding the outputs of the first block to the inputs of the second. The element $x+y \in M$ is defined if and only if $\mbox{out}(x) = \mbox{in}(y)$. The outputs of the first element must be equal in number to the inputs of the second element because they are ``fused'' in the sequence operation. Also matching the intuitive interpretation, we define 

\[
\mbox{in}(x+y) = \mbox{in}(x)
\]

since the inputs of the first block will become the inputs of the combined block. Similarly, we define

\[
\mbox{out}(x+y) = \mbox{out}(y)
\]

for the outputs.

\subsubsection{Parallel Composition}

The second elementary operator is called \emph{parallel composition}. We represent this operation as ``multiplication'' on the elements of $M$, i.e.,

\[
\times : M \times M \to M
\]

Intuitively, parallel composition fuses two blocks ``horizontally,'' where each block executes independently of one another, but they appear as a single block with combined inputs and outputs. The inputs of $x\times y$ are defined

\[
\mbox{in} (x \times y) = \mbox{in}(x)+\mbox{in}(y)
\]

and the outputs are defined

\[
\mbox{out}(x \times y) = \mbox{out}(x) + \mbox{out}(y)
\]

\subsubsection{Permutation and Identity Blocks}
\label{sec:code-gen:special}

In the abstract model, we define out a set of special blocks in $M$ called \emph{permutation} blocks. These blocks represent the primitive operation of taking $m$ inputs and ``wiring'' them to $n$ outputs in an arbitrary order. The intended interpretation is that the actual values are unchanged by the operation. Permutations may also ``drop'' an element by not wiring its input to any output, and ``duplicate'' elements by wiring an input to more than one output. The exact meaning of dropping or duplicating values depends on the implementation.

Formally, we name the block representing the permutation of $m$ inputs to $n$ outputs $\Pi_m(i_1,\ldots,i_n)$, where $i_1,\ldots,i_n \in \lbrace i \;|\; 1 \leq i \leq m \rbrace$.

\emph{Identity} blocks are a subset of the permutation blocks. The simplest of these is $\Pi_1(1)$, which acts as an identity transformation with one input and one output. That is, the block $\Pi_1(1)$ takes its single input and passes it unchanged to its single output. We refer to this element as $I_1$. In fact, there are an unlimited number of identity transformations, which take $n$ inputs to $n$ outputs, unchanged and without reordering. These are referred to as $I_n$, where $1 \leq n$, and $I_n = \Pi_n(1,2,\ldots,n)$. By definition, $\mbox{in}(I_n) = \mbox{out}(I_n) = n$.

When $n$ is implied from the context, we will sometimes write $I$ for $I_n$. For example, we use $x+I$ as a shorthand to refer to $x+I_n$ where it is understood that $n = \mathtt{out}(x)$.

Since the elements $I_n$ are intended to represent identity operations, we assign them a special meaning in the composition semantics. Namely, $I_n$ acts as both a left- and right-identity under the sequence operator. So, for any $x \in M$, we let $x + I_n$ be equivalent to $x$ where it is understood that $\mbox{out}(x) = n$. Similarly, $I_n + x$ is equivalent to $x$ for any $x \in M$ and where $\mbox{in}(x) = n$. We often use $I_n$ as a kind of ``no-op.''

It is worth noting one further identity, namely that $I_n$ is equivalent to the $n$-way parallel composition of $I_1$, that is

\[
I_n = \underbrace{I_1 \times \ldots \times I_1}_\text{n}
\]

Another important special block is the \emph{fanout} block, which takes a single input and copies it to $n$ outputs. We denote this block $F_n$. This turns out to be just another special case of the permutation block, so we can define 

\[
F_n \equiv \Pi_1(1,\ldots,n) 
\]

for the fanout block with $n$ outputs.

Note that \emph{any} object that provides and conforms to the operations above can be ``generated'' by Twig. Because the system is so general, this could include trivial or non-sensical implementations. To be used as we intended, the code generation implementation should conform to the intuitive interpretation of blocks and their composition.


\subsection{Generating C}
\label{sec:code-gen:c}

Now we will show how the model described above can be adapted to generate C code. 

You will notice that in the abstract model, we provide no way to construct ``primitive'' blocks, i.e., blocks that contain actual code. The only primitive blocks defined are the special permutation blocks, which by definition do nothing to the values. So, the first thing we need is a way to construct a primitive block from an arbitrary chunk of C code.

A primitive C block is just a string of C code with some annotations to indicate the inputs and outputs. In fact, our implementation makes no attempt to parse the C language \emph{per se} -- it simply accepts the C code as plain text.

We represent the inputs and outputs of each block as specially generated variables in C. To make use of the inputs and outputs, a block uses the escaped values \texttt{\$in1}, \texttt{\$in2}, etc. to represent the first, second, and so on values. Analogously, \texttt{\$out1}, \texttt{\$out2}, etc. represent the outputs. For the common case where a block has just one input and/or output, we allow \texttt{\$in} as a synonym for \texttt{\$in1}, and \texttt{\$out} for \texttt{\$out1}. When the code is rendered, these placeholders will be replaced with generated unique variable names. For example, the text 

\begin{verbatim}
$out = foo($in);
\end{verbatim}

represents a primitive C block with one input and one output. Figure~\ref{fig:blocks} shows a visual representation of two primitive blocks of C code.

\begin{figure}[ht]
\centering
\includegraphics[width=0.75\columnwidth]{images/code-gen1}
\caption{Two basic blocks, A and B. Inputs are on top, outputs on the bottom.}
\label{fig:blocks}
\end{figure}

To accomplish block sequencing in C, Twig generates variable names such that the output(s) of the first block in the sequence are the same as the inputs(s) of the second, and the text is concatenated. See Figure~\ref{fig:codegen-seq} for an example.

\begin{figure}[ht]
\centering
\includegraphics[width=0.75\columnwidth]{images/code-gen2}
\caption{Two blocks from Figure~\ref{fig:blocks} composed sequentially. The variable ``tmp'' is created, and renaming performed, so that the output of block A would flow to the input of block B.}
\label{fig:codegen-seq}
\end{figure}

Parallel composition for C is accomplished similarly; Twig generates independently-named variables for the inputs and outputs of the two blocks, and then concatenates the text. An example is shown in Figure~\ref{fig:codegen-par}.

\begin{figure}[ht]
\centering
\includegraphics[width=0.75\columnwidth]{images/code-gen3}
\caption{Two blocks from Figure~\ref{fig:blocks} composed in parallel. Renaming is performed such that the composed block has two inputs and two outputs.}
\label{fig:codegen-par}
\end{figure}

Finally, to implement the special permutation and identity blocks, it suffices to perform the appropriate bookkeeping on the variable names. The identity block, $I_1$, requires no generated code at all -- the variable name on the input is simply used for the output as well. More complex permutations work similarly -- Twig will rearrage the generated variable names, but no actual code needs to be generated.

Note that this implementation does not allocate or free memory, or otherwise perform resource management as part of the permutation operations. This implies that the generated code will follow C's semantics for passing by value versus reference. The user must keep these rules in mind when designing and using C typemaps in Twig.
