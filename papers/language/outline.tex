\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{url}
\usepackage{parskip}

\newcommand{\arr}[1]{\ensuremath\xrightarrow{#1}}

\begin{document}

\title{Twig Language: Outline}
\author{Geoff Hulette}

\maketitle


\section{Introduction}

Introduce Twig as a more formal alternative to Swig.

Swig introduced the concept of \emph{typemaps}, i.e. snippets of code that could
be used to convert data from one type to another in a given language. While
powerful, typemaps are not especially flexible -- you need to write a custom
typemap for every pair of types you want to convert.

Twig extends the ideas of Swig, with a notion of composable typemaps. We base
our design on Fig, but extend it in a few important ways.

First, Twig is not restricted to generate Moby bindings. It uses a novel model
for code generation that is both abstract and formal, and which is easy to
implement for both imperative and functional-style languages.

Second, Twig adds support for \emph{functors} -- a novel notion of datatypes
which contain other datatypes, and allow for compound conversions.

Third, Twig adds \emph{reductions} -- the ability for authors to provide rules
which can rewrite composite typemaps to simpler transformations according to
either general typemap algebra or domain-specific rules.

\section{Related Work}

Swig, Fig, Charon, lots of FFI systems. 

Clearly explain differences between Fig and Twig.


\section{Semantics}

\subsection{Code generation core}

Core language for code generation.

\subsection{Basic semantics}

Primitive rewriting steps.

\subsection{Basic combinators}

Sequence, choice, etc.

\subsection{Tuples}

Special tuple combinators.

\subsection{Functors}

Functors and polymorphic combinators.


\section{Implementation}



\section{Evaluation}

Compare against Swig. What do we want to show here?


\section{Conclusion}

Conclusion and future work.

\end{document}
