Dear Geoffrey Hulette,

On behalf of the GPCE 2012 Program Committee, I am delighted to inform you that
the following submission was accepted:

Composing Typemaps in Twig

You will find the reviews of your paper below. Please consider them very
carefully when preparing your revision. In a separate email you will receive
additional information on the camera-ready submission (with a deadline of July
9).

The reviews and comments are attached below.

Congratulations on your fine work. If you have any questions, please feel free
to get in touch.


Best Regards,
Walter Binder, Program Chair
GPCE 2012


----------------------- REVIEW 1 ---------------------
PAPER: 29
TITLE: Composing Typemaps in Twig
AUTHORS: Geoffrey Hulette, Matthew Sottile and Allen Malony

OVERALL RATING: 2 (accept)

Summary

Twig is a recent language for writing typemaps, i.e., transformations between
types in different languages, as they are necessary in multi-language
development. This paper provides a formal semantics for Twig and defines a code
generation model that separates language-independent code constructors from
language-specific mappings.

Assessment

I like this paper a lot! It's held in an unpretentious style and might make the
impression as if its subject is easy ("trivial") but in fact the formulations
are the result of proper, well though-out abstractions. Granted, typemaps do not
belong to today's killerapps but form a niche rather. Yet, for every designer of
typemaps this paper is, I think, a must-read.

Pro
- Foundational for future typemap designers
Cons
- None (perhaps: niche corner)

Minor comments

P2, l1:  other tools which -> other tools that
P2, -l5: can represent -> represent
P3, middle: patterns are terms which -> patterns are terms that
P3, middle: can also contain variables -> can also contain type variables
P3, -l11: full unification: it's "match" (one-sided unification) anyway, right?
P4, l2: there are some additional semantics -> there is some additional..
P4, l3: for lack of space: actually, you do have space
P4, l5: omitted semantics state -> omitted semantics states
P4, l13: semantics for congruence is -> semantics for congruence are
P4, l14: operator apply -> operator applies
P5, Figure 6: the premise should be t1->\perp .. t(i-1)-> \perp.
   Alternatively, you could change the caption to "#some operator"-rule
P5,-l6: where each block executes independently of one another -> where
   blocks execute independently of each other
P6, Figure 10: isn't permutation a strange name? Dropping and duplicating
   normally is not part of a permutation
P6, l1: There are an unlimited -> There is an unlimited
P6, l2: transformations which take -> transformations that take
P8, l7: This include: style (what is "this"?)
P8, bullet 5: Twig can be extended to generate target language other than C:
    which type systems can it deal with? What about subtyping, higher-order
    polymorphism and, generally, the various dimensions in the lambda cube?
P8, l3: polard: what is "polard"? A variable? A type constructor (but
   then it wouldn't be a term according to 3.1)
P9, sect. 6.2: could be written more as text
P10, Ref[5] messed up


----------------------- REVIEW 2 ---------------------
PAPER: 29
TITLE: Composing Typemaps in Twig
AUTHORS: Geoffrey Hulette, Matthew Sottile and Allen Malony

OVERALL RATING: 1 (weak accept)

Twig is a nice system that improves on existing work and provides an elegant way
of describing typemaps with an accent on functional composition, rather than on
code generation. The paper is also well written and accessible.

The paper has some drawbacks that I would like to ask the authors to address.

The numerous allusions to lack of space are a bit annoying given that the
authors have chosen a very spatious representation of the formal semantics.
Using a more compact representation would really improve the situation, and
allow to include all of the semantics.

Also, it is interesting to (repeatedly) read the claim that Twig supports
multiple target languages. This very feature, which is a major discriminator
from other tools in the field, is however not implemented, and the reader is
left to "just" believe it. The authors should either make the claim less
prominent, or provide an implementation (and demonstration thereof) to make it
more credible.


----------------------- REVIEW 3 ---------------------
PAPER: 29
TITLE: Composing Typemaps in Twig
AUTHORS: Geoffrey Hulette, Matthew Sottile and Allen Malony

OVERALL RATING: 0 (borderline paper)

The paper presents Twig, a small DSL for specifying mappings of types in one
language to types in another. The claim of novelty is that Twig's typemaps are
composable and more concise, unlike those one would write for Swig, a well-known
tool for generating glue code between native libraries and scripting languages.

This is nice work and the tool is undoubtably useful. However, the comparison
with related work and the evaluation is a lacking.

I question whether Twig is really that much more concise than Swig typemaps.
Couldn't the common code in Swig typemaps also be factored out into functions to
avoid duplication? Showing all the code in one figure rather than spread over
half a page would help make the comparison easier.

Evaluation on a larger example would be helpful. Small examples are nice in
Twig, but they're also quite nice in Swig as well. Showing where Swig starts to
break down would help make the point. For instance, how would one write typemaps
for a large library with many types like OpenGL or OpenCL or maybe an SMT
solver? Showing typemaps for JNI, say, might also be interesting.

The work is not put into context well. I am reminded of Nate Foster and Benjamin
Pierce et al.'s work on lenses and the Boomerang language. Twig's claims of
compositionality are similar, although targeted at a narrower domain. Boomerang
is addressing a much more general problem: bidirectional mapping of data, not
just type definitions. I think Boomerang could be used to build typemaps and
would have more-or-less the same composability properties as Twig. I haven't
checked this myself, but this should be addressed in the paper.

Fisher et al.'s PADS is also in a similar vein.
