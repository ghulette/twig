%!TEX root = twig.tex

\section{Term rewriting}
\label{sec:background:trs}

Term rewriting is a formal technique for reducing \emph{terms} to
some normal form with respect to a set of
rules~\cite{baader98term}. Much of the interest in term rewriting
stems from its utility in program
transformation~\cite{visser01survey}.

Terms are built from \emph{variables} and
\emph{constructors}~\cite{baader98term}. Variables are
placeholders for other terms. Constructors are functions from
terms to a single term, with some unique constant symbol and arity
$n \geq 0$. We adopt the convention that constructors symbols
begin with lowercase letters (e.g., \texttt{cons}), while
variables are usually represented by a single uppercase letter
(e.g., $X$). If a constructor has zero arity, we refer to it as a
\emph{constant symbol}. For example, $x$ and $y$ are both terms,
and if $\mathtt{cons}$ has arity 2, then $\mathtt{cons}(x,y)$ is
also a term. A \emph{signature} is a set of function symbols with
associated arities. Notably, the terms of a properly defined
signature can be used to represent the abstract syntax tree of a
program.

\emph{Rewrite rules} have the form $t_1 \to t_2$, and define a
transformation of a term matching the \emph{pattern} $t_1$ to a
term $t_2$. If the pattern $t_1$ contains variable terms, these
will be bound as a result of a successful pattern match. These
bindings may then be used in the construction of $t_2$.

Given a term $t$ and a set of rewrite rules $R$, we say that $t$
contains a \emph{redex} $s$ if $s$ is a subterm of $t$ and if $s$
matches one or more rewrite rules in $R$. A term is in
\emph{normal form} with respect to $R$ if it contains no redices.

The task of most term rewriting systems is the reduction of terms
to a normal form with respect to some set of rules $R$ by applying
rewrite rules to subterms until no more rules may be applied. In
general, a term may contain many redices; one challenge for term
rewriting implementations is to devise a \emph{strategy} for
deciding when and where to apply each rule within a
term~\cite{visser01survey}.

If repeated application of a set of rewrite rules is guaranteed to
eventually reduce to a normal form, then the rules are said to
\emph{terminate}. For example, consider the rule set containing
the single rule $\mathtt{f(X) \to f(f(x))}$. It is easy to see
that this rule will never terminate, because every application
grows the term and the redex still applies. Unsurprisingly then,
for a given a set of rules termination is undecidable in
general~\cite{baader98term}.

If a set of rules is terminating, and repeated application of a
set of rules will always produce a \emph{unique} normal form, then
the rules are said to be \emph{confluent}. Like termination,
confluence is undecidable in general. However, for rules which are
known to terminate, confluence is decidable~\cite{baader98term}.

\subsection{System S}

System S is a language that provides the basic machinery for term
rewriting~\cite{visser98core}. It can be used to implement
different term rewriting strategies, that is, methods for deciding
which redices to reduce, and when to reduce them relative to other
redices. As we will discuss in Chapter~\ref{ch:semantics}, System
S is the basis for Twig's language.

Terms in System S are defined formally, but the rules for
constructors, variables, and pattern matching are very similar to
the canonical definitions given above, so we omit the details
here.

In System S, a rule $s$ is a binary relation $\arr{s} \subseteq
\mathcal{S} \times (\mathcal{S} \cup \bot )$, where $\mathcal{S}$
is a set of terms and $\bot$ is a special term indicating failure.
Specifically, we say that $t \arr{s} t'$ succeeds if and only if
$(t,t') \in \arr{s}$, and $t' \neq \bot$. If $(t,t') \in \arr{s}$,
but $t' = \bot$, we say it fails. If $(t,t') \notin \arr{s}$ then
$t \arr{s} t'$ is undefined in $s$.

\emph{Atomic} rules are just primitive defined rules $t \to t'$,
and rules may be defined to fail. System S introduces a set of
compositions on rules that allow new rules to be created from
existing ones. The complete semantics for these compositions are
given in~\cite{visser98core}. The compositions include a
sequencing operator $;$, where for rules $s1$ and $s2$, $s1;s2$
applies $s1$ first and, if it succeeds, applies $s2$ to the result
(and fails otherwise). Other combinators include deterministic and
non-deterministic choice, a fixed-point operator that allows
recursive composition, as well as a set of operators to traverse
subterms by enumerating them. Twig makes use of these operators as
well, although we extend their semantics to support code
generation.

\subsection{Twig (Aho et al.)}

Aho's Twig~\cite{aho-twig} is a language (not to be confused with
our own language, also called Twig) that uses tree rewriting rules
to specify code generators for compiler back-ends. Twig's
rewriting rules operate on intermediate representation trees,
which encode a program at the level of the target machine. Rules
specify a \emph{template} tree, a \emph{replacement} node, a
\emph{cost function}, and a block of object code that will be
emitted as a side-effect of the rule being applied. Emitting code
in this way is similar to our own scheme, although in our language
the ordering of side-effects is controlled by the user through
rewriting strategies, whereas in Twig the ordering is decided
through a combination of depth-first traversal and dynamic
programming based on the cost function for each rule. The cost
function allows Twig to generate object code that is optimal, up
to the accuracy of the given costs.

Twig differs from our own language in that the rewrite rules are
applied to program trees. In our Twig, rewrites are applied to
types. Our Twig is able to take a somewhat looser approach to
rewrite rules, e.g. rules need not reduce to a single node and may
contain variables. Our Twig has this freedom since we rely on
user-provided strategies to control rule application. Their Twig's
use of cost functions to control application provides an
interesting metric for comparing application strategies -- it
would be quite interesting to try to incorporate something similar
into our own language.
